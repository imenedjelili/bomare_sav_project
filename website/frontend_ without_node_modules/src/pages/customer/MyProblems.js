// src/pages/customer/MyProblems.js
import React, { useState, useEffect, useMemo } from 'react';
import { Link, useNavigate, useLocation } from 'react-router-dom';
import { FiPlusCircle } from 'react-icons/fi';
import { supabase } from '../../supabaseClient';
import './MyProblems.css';

// Define the status mapping clearly, matching potential DB values in 'status_problem'
// Keys are now case-sensitive to match DB values and CHECK constraint.
const STATUS_MAPPING = {
    'Pending':    { key: 'Pending',    label: 'En Attente', cssClass: 'pending',    text: 'En attente de réponse' },
    'inprogress': { key: 'inprogress', label: 'Ouvert',     cssClass: 'inprogress', text: 'En cours de traitement' }, // Assuming lowercase in DB
    'planned':    { key: 'planned',    label: 'Ouvert',     cssClass: 'inprogress', text: 'Planifié' },                // Assuming lowercase in DB
    'Resolved':   { key: 'Resolved',   label: 'Résolu',     cssClass: 'resolved',   text: 'Résolu' },
    'closed':     { key: 'closed',     label: 'Clôturé',    cssClass: 'closed',     text: 'Clôturé' },                // Assuming lowercase in DB
    'expired':    { key: 'expired',    label: 'Expiré',     cssClass: 'expired',    text: 'Expiré' },                 // From check constraint
    'unknown':    { key: 'unknown',    label: 'Inconnu',    cssClass: 'unknown',    text: 'Statut Inconnu' },
};

// Problem tab configuration with explicit mapping to DB status keys for filtering
// statusKeys now match the case-sensitive keys in STATUS_MAPPING
const problemTabsConfig = [
  { key: 'all',        label: 'Tous',
    statusKeys: Object.keys(STATUS_MAPPING).filter(k => k !== 'unknown' && k !== 'expired') // Filter out 'expired' if it's not a typical problem status
  },
  { key: 'inprogress', label: 'Ouvert',       statusKeys: ['inprogress', 'planned'] }, // These are still lowercase as per original assumption
  { key: 'pending',    label: 'En Attente',   statusKeys: ['Pending'] },             // Match 'Pending'
  { key: 'resolved',   label: 'Résolu',       statusKeys: ['Resolved', 'closed'] },  // Match 'Resolved'
];


const MyProblems = () => {
  const navigate = useNavigate();
  const location = useLocation();
  const [activeTabKey, setActiveTabKey] = useState('all');
  const [allUserProblems, setAllUserProblems] = useState([]);
  const [filteredProblems, setFilteredProblems] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);
  const [currentProblemUpdating, setCurrentProblemUpdating] = useState(null);

  const queryParams = new URLSearchParams(location.search);
  const productSerialFilter = queryParams.get('productSerial');

  useEffect(() => {
    const fetchProblems = async () => {
      setIsLoading(true);
      setError(null);

      const { data: { user: authUser }, error: authError } = await supabase.auth.getUser();
       if (authError || !authUser) {
         setError("Vous devez être connecté pour voir vos problèmes.");
         setIsLoading(false);
         return;
       }

       try {
         const { data: problemsData, error: problemsError } = await supabase
             .from('customer_tickets')
             .select(`
                id,
                problem,
                status_problem,
                created_at,
                updated_at,
                customer_id,
                customer_product (
                    id,
                    serie_number,
                    produc_name,
                    products (
                        product_name
                    )
                )
             `)
             .eq('customer_id', authUser.id)
             .order('created_at', { ascending: false });

         if (problemsError) {
           console.error("Error fetching user problems:", problemsError);
           setError(`Impossible de charger vos problèmes d'assistance. Détail: ${problemsError.message}`);
           setAllUserProblems([]);
         } else {
            console.log("Fetched problems from DB:", problemsData);
             const mappedProblems = problemsData
               .filter(p => p.customer_product !== null)
               .map(p => {
                 // p.status_problem will be like 'Pending', 'Resolved', 'inprogress', etc.
                 const statusKeyFromDb = p.status_problem || 'unknown';
                 const statusDetails = STATUS_MAPPING[statusKeyFromDb] || STATUS_MAPPING['unknown'];

                 return {
                   id: p.id,
                   title: p.problem ? (p.problem.length > 80 ? p.problem.substring(0, 80) + '...' : p.problem) : 'Problème signalé',
                   statusKey: statusKeyFromDb, // Store the original DB status_problem value
                   status: statusDetails.text, // Get text from mapping
                   signalDate: p.created_at ? new Date(p.created_at).toLocaleDateString('fr-FR') : 'Date inconnue',
                   lastUpdate: p.updated_at ? new Date(p.updated_at).toLocaleDateString('fr-FR') : (p.created_at ? new Date(p.created_at).toLocaleDateString('fr-FR') : 'Jamais'),
                   productName: p.customer_product?.products?.product_name || p.customer_product?.produc_name || 'Produit inconnu',
                   productSerial: p.customer_product?.serie_number || 'N/A',
                 };
               });
            console.log("Mapped problems for UI:", mappedProblems);
           setAllUserProblems(mappedProblems);
         }
       } catch (err) {
         console.error("Unexpected error fetching user problems:", err);
         setError("Une erreur inattendue s'est produite lors du chargement des problèmes.");
         setAllUserProblems([]);
       } finally {
          setIsLoading(false);
       }
    };
    fetchProblems();
  }, []);

   useEffect(() => {
     let problemsToShow = allUserProblems;
     if (activeTabKey !== 'all') {
       const tabConfig = problemTabsConfig.find(tab => tab.key === activeTabKey);
       if (tabConfig && tabConfig.statusKeys && tabConfig.statusKeys.length > 0) {
           problemsToShow = problemsToShow.filter(p => tabConfig.statusKeys.includes(p.statusKey)); // Direct comparison with p.statusKey
       } else if (tabConfig) {
            problemsToShow = [];
       }
     }

     if (productSerialFilter) {
         problemsToShow = problemsToShow.filter(p => p.productSerial === productSerialFilter);
     }
     problemsToShow.sort((a, b) => new Date(b.signalDate) - new Date(a.signalDate)); // This sort might need adjustment if signalDate is string "Date inconnue"
     setFilteredProblems(problemsToShow);
   }, [activeTabKey, allUserProblems, productSerialFilter]);

  const problemCounts = useMemo(() => {
      return problemTabsConfig.reduce((acc, tab) => {
          if (tab.key === 'all') {
               acc[tab.key] = allUserProblems.filter(p => p.statusKey !== 'unknown' && p.statusKey !== 'expired').length;
          } else {
              acc[tab.key] = allUserProblems.filter(p => tab.statusKeys.includes(p.statusKey)).length; // Direct comparison
          }
          return acc;
      }, {});
   }, [allUserProblems]);

   const handleCloseProblem = async (problemId) => {
        const problemToClose = allUserProblems.find(p => p.id === problemId);
        if (!problemToClose) {
             console.warn(`Attempted to close non-existent problem ID: ${problemId}`);
            return;
        }
        if (!window.confirm(`Voulez-vous vraiment clôturer le problème "${problemToClose.title}" (ID: ${problemId}) ? Cette action est irréversible.`)) {
            return;
        }
       setCurrentProblemUpdating(problemId);
       try {
           const { error: updateError } = await supabase
               .from('customer_tickets')
               .update({ status_problem: 'closed', updated_at: new Date().toISOString() }) // Assuming 'closed' is a valid state for updates
               .eq('id', problemId);

           if (updateError) {
               console.error("Error closing problem:", updateError);
               alert(`Échec de la clôture du problème ${problemId}. Veuillez réessayer. Détail: ${updateError.message}`);
           } else {
                console.log(`Problem ${problemId} marked as closed in DB.`);
                setAllUserProblems(prevProblems =>
                   prevProblems.map(p =>
                      p.id === problemId
                         ? {
                             ...p,
                             statusKey: 'closed',
                             status: STATUS_MAPPING['closed'].text,
                             lastUpdate: new Date().toLocaleDateString('fr-FR')
                           }
                         : p
                   )
                );
               alert(`Problème ${problemId} clôturé avec succès.`);
           }
       } catch (err) {
            console.error("Unexpected error closing problem:", err);
             alert(`Une erreur inattendue s'est produite lors de la clôture du problème ${problemId}.`);
       } finally {
           setCurrentProblemUpdating(null);
       }
   };

  if (isLoading) {
      return (
         <div className="my-problems-page fade-in-up">
              <div className="page-header"><h1>Chargement...</h1><p className="text-secondary">Chargement de vos demandes d'assistance.</p></div>
           </div>
      );
  }

   if (error) {
      return (
         <div className="my-problems-page fade-in-up">
              <div className="page-header"><h1>Erreur</h1><p className="text-secondary">Impossible de charger vos demandes.</p></div>
               <div className="custom-card auth-message error" style={{ maxWidth: '600px', margin: '20px auto' }}>
                 <p>{error}</p>
                 {error.includes("connecté") && (<Link to="/login" className="btn btn-primary" style={{marginTop: '15px'}}>Se connecter</Link>)}
              </div>
           </div>
      );
   }

  return (
    <div className="my-problems-page fade-in-up">
      <div className="page-header">
        <h1>Mes Problèmes</h1>
        <p className="text-secondary">Suivez et gérez vos demandes d'assistance.</p>
         {productSerialFilter && (<p className="text-secondary" style={{ marginTop: '10px', fontWeight: 'bold' }}>Filtré par Produit : {productSerialFilter}</p>)}
      </div>

      <div className="problems-controls-header">
        <div className="problem-filters-container">
          {problemTabsConfig.map(tab => (
            <button
              key={tab.key}
              className={`problem-filter-btn ${activeTabKey === tab.key ? 'active' : ''}`}
              onClick={() => setActiveTabKey(tab.key)}
              aria-pressed={activeTabKey === tab.key}
              disabled={isLoading || currentProblemUpdating !== null}
            >
              {tab.label} ({problemCounts[tab.key] || 0})
            </button>
          ))}
        </div>
        <button
            className="btn btn-primary btn-icon report-new-problem-btn-header"
            onClick={() => navigate('/customer/report-issue')}
            title="Signaler un nouveau problème"
             disabled={isLoading || currentProblemUpdating !== null}
        >
            <FiPlusCircle size={16} style={{marginRight: '8px'}} />
            Signaler un problème
        </button>
      </div>

      <div className="problems-list-container">
        {filteredProblems.length > 0 ? (
          filteredProblems.map(problem => (
            <div key={problem.id} className="problem-item-card">
              <div className="problem-card-main-content">
                <h3>{problem.title}</h3>
                <p className="problem-meta-info text-secondary">
                  ID du problème : {problem.id} | Produit : {problem.productName} ({problem.productSerial}) | Signalé : {problem.signalDate}
                </p>
                <p className="problem-meta-info text-secondary">
                  Dernière mise à jour : {problem.lastUpdate}
                </p>
              </div>

              <div className="problem-card-footer">
                <span
                  className={`status-badge-myproblems status-myproblems-${STATUS_MAPPING[problem.statusKey]?.cssClass || STATUS_MAPPING['unknown'].cssClass}`}
                  title={`Statut: ${problem.status}`}
                >
                  {STATUS_MAPPING[problem.statusKey]?.label || STATUS_MAPPING['unknown'].label}
                </span>

                 {['Pending', 'inprogress', 'planned'].includes(problem.statusKey) && ( // Note: 'Pending' is capitalized
                    <Link to={`/customer/my-problems/detail/${problem.id}`} className="btn btn-secondary" disabled={currentProblemUpdating !== null}>
                      Voir les détails
                   </Link>
                 )}
                 {problem.statusKey === 'Resolved' && ( // Note: 'Resolved' is capitalized
                    <>
                       <button
                           className="btn btn-secondary"
                           onClick={() => handleCloseProblem(problem.id)}
                           disabled={currentProblemUpdating === problem.id || currentProblemUpdating !== null}
                       >
                          {currentProblemUpdating === problem.id ? 'Clôture...' : 'Clôturer'}
                       </button>
                        <Link to={`/customer/my-problems/detail/${problem.id}`} className="btn btn-secondary" style={{ marginLeft: '10px' }} disabled={currentProblemUpdating !== null}>
                          Voir les détails
                       </Link>
                   </>
                 )}
                 {problem.statusKey === 'closed' && (
                      <Link to={`/customer/my-problems/detail/${problem.id}`} className="btn btn-secondary" disabled={currentProblemUpdating !== null}>
                        Voir les détails
                     </Link>
                 )}
                 {problem.statusKey === 'unknown' && (
                      <span className="text-secondary">Pas d'action disponible pour statut inconnu</span>
                 )}
              </div>
            </div>
          ))
        ) : (
          <div className="custom-card no-problems-card-alt">
            <p className="text-secondary">
               {allUserProblems.length === 0 ?
                   "Vous n'avez signalé aucun problème pour le moment." :
                   productSerialFilter ?
                   `Aucun problème trouvé pour le produit ${productSerialFilter} correspondant à votre filtre "${problemTabsConfig.find(t => t.key === activeTabKey)?.label || 'Tous'}".` :
                   `Aucun problème trouvé correspondant à votre filtre "${problemTabsConfig.find(t => t.key === activeTabKey)?.label || 'Tous'}".`
               }
            </p>
            <Link to="/customer/report-issue" className="btn btn-primary btn-icon" disabled={isLoading || currentProblemUpdating !== null}>
               <FiPlusCircle size={18} style={{ marginRight: '6px' }}/>
               Signaler un nouveau problème
             </Link>
             { productSerialFilter && (allUserProblems.length > 0) && (
                <Link to="/customer/my-problems" className="btn btn-secondary" style={{marginTop: '10px'}} disabled={isLoading || currentProblemUpdating !== null}>
                    Voir tous mes problèmes
                </Link>
            )}
          </div>
        )}
      </div>
    </div>
  );
};

export default MyProblems;
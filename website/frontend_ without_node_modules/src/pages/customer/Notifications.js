// src/pages/customer/Notifications.js
import React, { useState, useEffect, useMemo } from 'react';
import { Link } from 'react-router-dom';
import {
  FiBell,
  FiMessageCircle,
  FiTool,
  FiShield,
  FiSettings,
  FiCheck,
  FiEye
} from 'react-icons/fi';
// import { mockNotifications as initialNotifications } from '../../services/mockData'; // Remove mock data
import { supabase } from '../../supabaseClient'; // Import supabase client
import './Notifications.css';

const notificationTabsConfig = [
  { key: 'all', label: 'Tout' },
  { key: 'unread', label: 'Non lus' },
  { key: 'updates', label: 'Mises à jour des problèmes' }, // Example grouping of types
  { key: 'warranty', label: 'Garantie' }, // Example specific type
  { key: 'system', label: 'Système' }, // Example specific type
];

// Mapping for notification types from DB to front-end display/icon
const NOTIFICATION_TYPE_MAPPING = { // Match keys to your DB 'type' column values
    'update': { label: 'Mise à jour', icon: <FiBell /> },
    'assignment': { label: 'Assignation', icon: <FiTool /> },
    'info': { label: 'Information', icon: <FiMessageCircle /> },
    'warranty': { label: 'Garantie', icon: <FiShield /> },
    'system': { label: 'Système', icon: <FiSettings /> },
    // Add more types
    'other': { label: 'Autre', icon: <FiBell /> }, // Default
};

// Map notification types used in the 'updates' tab filter
const UPDATES_TYPES = ['update', 'assignment', 'info'];


const Notifications = () => {
  const [activeTabKey, setActiveTabKey] = useState('all');
  const [allNotifications, setAllNotifications] = useState([]); // Store all fetched notifications
  // displayedNotifications state is no longer strictly necessary as useMemo returns the filtered list directly
  // const [displayedNotifications, setDisplayedNotifications] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);


  // Fetch user's notifications on mount or auth state change
  useEffect(() => {
    let isMounted = true; // Cleanup flag

    const fetchNotifications = async (userId) => { // Accept user ID as parameter
      setIsLoading(true);
      setError(null);

      // --- Add this explicit check for userId BEFORE fetching ---
       if (!userId) {
          console.log("Notifications.js: No user ID available, skipping fetch.");
          // setError("Authentification requise ou profil non chargé."); // This error might be confusing if ProtectedRoute handles it
          setIsLoading(false);
          setAllNotifications([]); // Clear any old data
          return; // Exit early if no user ID
       }
      // --- End of check ---

       // --- ADD THIS LOGGING LINE ---
       console.log(`Notifications.js: Fetching notifications for user ID: ${userId}`);
       // --- END LOGGING LINE ---


      try {
        // Fetch notifications from your 'notifications' table
        const { data: notificationsData, error: notificationsError } = await supabase
            .from('notifications') // Ensure this table name is correct ('notifications')
            .select(`id, title, message, type, is_read, created_at`)
            .eq('customer_id', userId) // Use the provided user ID
            .order('created_at', { ascending: false }); // Order by date descending

        if (!isMounted) return;

        if (notificationsError) {
          console.error("Error fetching notifications:", notificationsError);
          // The 400 error message from Supabase might be in notificationsError.message
          setError(`Impossible de charger vos notifications. Détails: ${notificationsError.message || 'Erreur inconnue'}`);
          setAllNotifications([]); // Clear state on error
        } else {
             console.log("Fetched notifications:", notificationsData);
             // Map fetched data to a format convenient for the component's state/rendering
            const mappedNotifications = notificationsData.map(n => ({
                id: n.id,
                title: n.title || 'Notification',
                message: n.message,
                type: n.type || 'other', // Use DB 'type' column, default to 'other' if null/undefined
                unread: !n.is_read, // Assuming 'is_read' is a boolean in DB
                // Using created_at timestamp directly, sort will parse it.
                time: n.created_at ? n.created_at : new Date().toISOString(),
            }));
           setAllNotifications(mappedNotifications); // Store all fetched notifications in state
        }
      } catch (err) {
         if (!isMounted) return;
         console.error("Unexpected error during notifications fetch:", err);
          setError("Une erreur inattendue est survenue lors du chargement de vos notifications.");
         setAllNotifications([]);
      } finally {
        if (isMounted) setIsLoading(false);
      }
    };

    // Get the current user when the component mounts or auth state changes
    const checkUserAndFetch = async () => {
        const { data: { user }, error: authError } = await supabase.auth.getUser();
        if (!isMounted) return;

        if (authError || !user) {
             console.log("Notifications.js useEffect: User not found after getUser.");
            // User is not authenticated or an error occurred getting user
            // ProtectedRoute should handle redirection, but ensure this component
            // displays an appropriate state if it somehow renders without a user.
            fetchNotifications(null); // Call fetchNotifications with null user ID
        } else {
            console.log("Notifications.js useEffect: User found, fetching notifications.");
            fetchNotifications(user.id); // Call fetchNotifications with the user's ID
        }
    };

    // Listen for auth state changes and re-fetch
    const { data: { subscription } } = supabase.auth.onAuthStateChange((_event, session) => {
         console.log('Auth state change detected in Notifications.js:', _event);
         // When auth state changes, re-check the user and fetch notifications
         // session?.user might be null if logging out
         fetchNotifications(session?.user?.id || null); // Pass user ID or null
    });

    // Initial check and fetch when the component first mounts
    checkUserAndFetch();


    // Cleanup subscription on component unmount
    return () => {
         isMounted = false;
         if (subscription) subscription.unsubscribe();
    };

  }, []);


   // Use useMemo to calculate filtered and sorted notifications
   const memosizedDisplayedNotifications = useMemo(() => {
       console.log("Filtering/Sorting notifications...");
       let filtered = allNotifications;

       // Apply Tab Filtering based on `activeTabKey`
       if (activeTabKey === 'unread') {
           filtered = filtered.filter(n => n.unread);
       } else if (activeTabKey === 'updates') { // Grouping multiple types
           filtered = filtered.filter(n => UPDATES_TYPES.includes(n.type));
       }
       else if (activeTabKey !== 'all') { // Specific type filters (e.g., 'warranty', 'system')
           filtered = filtered.filter(n => n.type === activeTabKey);
       }


        // Sort Filtered Notifications (unread first, then by date descending)
       filtered.sort((a, b) => {
           if (a.unread && !b.unread) return -1;
           if (!a.unread && b.unread) return 1;

            const timeA = new Date(a.time).getTime();
            const timeB = new Date(b.time).getTime();

            if (isNaN(timeA) && isNaN(timeB)) return 0;
            if (isNaN(timeA)) return 1;
            if (isNaN(timeB)) return -1;

            return timeB - timeA; // Most recent first
        });

       return filtered.map(n => ({
           ...n,
            formattedTime: n.time ? new Date(n.time).toLocaleString() : 'Date inconnue'
       }));

   }, [activeTabKey, allNotifications]);


   // Calculate counts for tabs using useMemo
    const notificationCounts = useMemo(() => {
        console.log("Recalculating notification counts...");
        return notificationTabsConfig.reduce((acc, tab) => {
            if (tab.key === 'all') {
                acc[tab.key] = allNotifications.length;
            } else if (tab.key === 'unread') {
                acc[tab.key] = allNotifications.filter(n => n.unread).length;
            } else if (tab.key === 'updates') {
                acc[tab.key] = allNotifications.filter(n => UPDATES_TYPES.includes(n.type)).length;
            } else { // Specific types
                acc[tab.key] = allNotifications.filter(n => n.type === tab.key).length;
            }
            return acc;
        }, {});
    }, [allNotifications]);


  const markAllAsRead = async () => {
     if (!window.confirm("Voulez-vous marquer toutes les notifications comme lues ?")) {
         return;
     }

    const currentlyUnreadNotifications = allNotifications.filter(n => n.unread);
    if (currentlyUnreadNotifications.length === 0) {
         console.log("No unread notifications to mark.");
         return;
    }

    const updatedNotifications = allNotifications.map(n => ({ ...n, unread: false }));
    setAllNotifications(updatedNotifications);


     console.log("Attempting to mark all as read in DB...");

    try {
       const { data: { user: authUser }, error: authError } = await supabase.auth.getUser();
       if (authError || !authUser) {
           console.error("Not authenticated to mark as read. Reverting UI optimistic update.");
            setError("Erreur : Vous n'êtes pas connecté.");
             setAllNotifications(allNotifications);
            return;
       }

       const unreadIds = currentlyUnreadNotifications.map(n => n.id);
       const { error: updateError } = await supabase
           .from('notifications')
           .update({ is_read: true })
           .in('id', unreadIds);


        if (updateError) {
             console.error("Error marking all as read in DB:", updateError);
             setError(`Échec de la mise à jour de votre statut de lecture: ${updateError.message}`);
             console.warn("Reverting optimistic update for 'mark all as read' due to DB error.");
             setAllNotifications(allNotifications);

        } else {
             console.log("All notifications marked as read in DB successfully.");
        }
    } catch (err) {
       console.error("Unexpected error marking all as read:", err);
        setError("Une erreur inattendue est survenue lors de la mise à jour.");
        setAllNotifications(allNotifications);
    }
  };

  const markAsRead = async (id) => {
    const notificationToUpdate = allNotifications.find(n => n.id === id);
    if (!notificationToUpdate || !notificationToUpdate.unread) {
        return;
    }

    const updatedNotifications = allNotifications.map(n =>
       n.id === id ? { ...n, unread: false } : n
    );
    setAllNotifications(updatedNotifications);


     console.log(`Attempting to mark notification ${id} as read in DB...`);

    try {
       const { error: updateError } = await supabase
           .from('notifications')
           .update({ is_read: true })
           .eq('id', id);


        if (updateError) {
             console.error(`Error marking notification ${id} as read in DB:`, updateError);
              setError(`Échec de la mise à jour de la notification ${id}. Détails: ${updateError.message}`);
              setAllNotifications(prev => prev.map(n => n.id === id ? {...n, unread: true} : n));
        } else {
            console.log(`Notification ${id} marked as read in DB successfully.`);
        }
    } catch (err) {
         console.error(`Unexpected error marking notification ${id} as read:`, err);
          setError(`Une erreur inattendue est survenue lors de la mise à jour de la notification ${id}.`);
         setAllNotifications(prev => prev.map(n => n.id === id ? {...n, unread: true} : n));
    }
  };

  const getNotificationIcon = (typeKey) => {
    const iconSize = 20;
    const typeConfig = NOTIFICATION_TYPE_MAPPING[typeKey] || NOTIFICATION_TYPE_MAPPING['other'];
    return React.cloneElement(typeConfig.icon, { size: iconSize });
  };

   const unreadTotalCount = allNotifications.filter(n => n.unread).length;


   if (isLoading) {
       return (
            <div className="notifications-page fade-in-up">
                 <div className="page-header">
                     <h1>Chargement...</h1>
                    <p className="text-secondary">Chargement de vos notifications.</p>
                    <div style={{marginTop: '20px'}}><div className="loading-spinner"></div></div>
                 </div>
            </div>
       );
   }

    if (error) {
       return (
          <div className="notifications-page fade-in-up">
               <div className="page-header">
                 <h1>Erreur</h1>
                 <p className="text-secondary">Une erreur est survenue lors du chargement de vos notifications.</p>
               </div>
                <div className="custom-card auth-message error" style={{ maxWidth: '600px', margin: '20px auto' }}>
                  <p>{error}</p>
               </div>
               {/* Optional retry button */}
               {/* <div style={{textAlign: 'center', marginTop: '20px'}}>
                    <button onClick={() => window.location.reload()} className="btn btn-primary">Réessayer</button>
               </div> */}
            </div>
       );
    }


  return (
    <div className="notifications-page fade-in-up">
      <div className="page-header">
        <h1>Notifications</h1>
        <p className="text-secondary">Restez informé de vos demandes d'assistance et des informations sur la garantie.</p>
      </div>

      <div className="notifications-controls-header">
        <div className="notification-filters-container">
          {notificationTabsConfig.map(tab => (
            <button
              key={tab.key}
              className={`notification-filter-btn ${activeTabKey === tab.key ? 'active' : ''}`}
              onClick={() => setActiveTabKey(tab.key)}
              aria-pressed={activeTabKey === tab.key}
               disabled={isLoading}
            >
              {tab.label} ({notificationCounts[tab.key] || 0})
            </button>
          ))}
        </div>
        {/* Show "Mark all as read" button only if there are unread notifications */}
        {unreadTotalCount > 0 && (
             <button
                className="btn btn-primary btn-sm mark-all-read-action-btn"
                onClick={markAllAsRead}
                aria-label="Marquer toutes les notifications comme lues"
                 disabled={isLoading} // Disable while loading
              >
                <FiCheck size={16} style={{ marginRight: '6px' }} /> Marquer tout comme lu
            </button>
        )}
      </div>

      <div className="notifications-list-container">
         {/* Render based on the memoized and filtered/sorted list */}
        {memosizedDisplayedNotifications.length > 0 ? (
          memosizedDisplayedNotifications.map(notification => (
            <div
              key={notification.id} // Use DB ID as key
              className={`custom-card notification-item ${notification.unread ? 'unread' : ''}`}
              role="listitem"
              // Optional: Add onClick to the item itself to also mark as read and/or navigate
              // onClick={() => { markAsRead(notification.id); /* navigate to detail? */ }}
            >
              {/* Unread Indicator Dot */}
              {notification.unread && <div className="unread-indicator-dot" aria-label="Notification non lue"></div>}

              <div className="notification-item-icon-area" aria-hidden="true">
                {getNotificationIcon(notification.type)}
              </div>
              <div className="notification-item-content">
                <h4>{notification.title}</h4>
                {/* Check if message exists before rendering the paragraph */}
                {notification.message && <p className="text-secondary notification-message">{notification.message}</p>}
                <span className="notification-time text-secondary">{notification.formattedTime}</span> {/* Use formatted time */}
              </div>
              <div className="notification-item-action">
                 {/* Link should go to relevant details, likely problem details for problem updates */}
                 {/* Example Link (adjust target route based on notification.type) */}
                 {/* Using a simple Link here, consider a Button if it's just an action */}
                <Link
                    to={`/customer/notifications/detail/${notification.id}`} // Generic link example
                    className="btn btn-secondary btn-sm"
                    onClick={() => markAsRead(notification.id)} // Mark as read when link is clicked
                    title={`Voir les détails de: ${notification.title}`}
                    aria-label={`Voir les détails de la notification: ${notification.title}`}
                     disabled={isLoading}
                >
                  <FiEye size={14} style={{ marginRight: '5px' }} /> Voir les détails
                </Link>
              </div>
            </div>
          ))
        ) : (
          <div className="custom-card no-notifications-message">
            <p className="text-secondary">
               {/* Display message based on filter */}
               Aucune notification à afficher pour "{notificationTabsConfig.find(t => t.key === activeTabKey)?.label || 'cette catégorie'}".
            </p>
          </div>
        )}
      </div>
    </div>
  );
};

export default Notifications;
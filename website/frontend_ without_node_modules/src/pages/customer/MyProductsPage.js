
// src/pages/customer/MyProductsPage.js
import React, { useState, useEffect, useMemo } from 'react';
import { Link, useNavigate } from 'react-router-dom';
import {
  FiTv,
  FiSmartphone,
  FiSpeaker,
  FiHardDrive,
  FiAlertTriangle,
  FiInfo,
  FiChevronDown,
  FiChevronUp,
  FiPlusCircle
} from 'react-icons/fi';
import { supabase } from '../../supabaseClient'; // Import supabase client
import './MyProductsPage.css';
import '../customer/WarrantyProducts.css'; // Import warranty badge styles if shared

// Map status keys from DB (status_warranty) to front-end keys/text/CSS classes
const WARRANTY_STATUS_MAPPING = { // Define or import from a shared constants file
    'active': { key: 'active', text: 'Sous Garantie', cssClass: 'active' },
    'expired': { key: 'expired', text: 'Expirée', cssClass: 'expired' },
    'extended': { key: 'extended', text: 'Prolongée', cssClass: 'extended' },
    'under warranty': { key: 'active', text: 'Sous Garantie', cssClass: 'active' }, // Ensure DB default value is mapped
    // Add other statuses from your DB schema if needed
    'unknown': { key: 'unknown', text: 'Statut Inconnu', cssClass: 'unknown' },
};

// Map product types from DB (assuming your 'products' table has a 'type' column)
// Ensure keys here match the values you expect in the 'type' column of your 'products' table (lowercase)
const PRODUCT_TYPE_MAPPING = {
    'tv': { label: 'Téléviseur', icon: <FiTv /> },
    'smartphone': { label: 'Smartphone', icon: <FiSmartphone /> },
    'audio': { label: 'Audio', icon: <FiSpeaker /> },
    // Add other product types you expect from the DB 'products.type' column
    'other': { label: 'Autre', icon: <FiHardDrive /> }, // Fallback type
};


// Product filter tabs configuration
const productFilterTabsConfig = [
  { key: 'all', label: 'Tous les Produits', icon: null },
  { key: 'tv', label: 'Téléviseurs', icon: <FiTv size={16}/> }, // Use lowercase keys corresponding to DB values
  { key: 'smartphone', label: 'Smartphones', icon: <FiSmartphone size={16}/> },
  { key: 'audio', label: 'Audio', icon: <FiSpeaker size={16}/> },
  { key: 'active_problem', label: 'Avec Problèmes Actifs', icon: <FiAlertTriangle size={16}/> },
];

// Reusable ProductCard component - Update to use data structure from DB fetch
const ProductCard = ({ product, onSelectProduct, isSelected }) => {
  const navigate = useNavigate();

  const handleViewProductProblems = (e) => {
    e.stopPropagation(); // Prevent card selection toggle when clicking this specific button
    // Navigate to "Mes Problèmes" page, with productSerial as a query parameter
    navigate(`/customer/my-problems?productSerial=${product.serial}`);
    // Note: MyProblemsPage has been adapted to read and use this 'productSerial' query parameter.
  };

    const getProductTypeIcon = (typeKey) => {
        const iconSize = 22;
        // Use lowercase typeKey for lookup in the mapping
        const typeConfig = PRODUCT_TYPE_MAPPING[typeKey?.toLowerCase()] || PRODUCT_TYPE_MAPPING['other'];
        return React.cloneElement(typeConfig.icon, { size: iconSize, className: `product-type-icon ${typeKey === 'other' ? 'secondary' : 'accent'}` });
    };

    // Get mapped warranty status details using the statusKey from the DB
     const warrantyStatus = WARRANTY_STATUS_MAPPING[product.statusKey?.toLowerCase()] || WARRANTY_STATUS_MAPPING['unknown'];


  return (
    <div
      className={`product-item-card ${isSelected ? 'selected expanded' : ''}`}
      onClick={() => onSelectProduct(product.id)} // Use DB 'id' for selection state
      role="button"
      aria-expanded={isSelected}
      tabIndex={0}
      onKeyPress={(e) => (e.key === 'Enter' || e.key === ' ') && onSelectProduct(product.id)}
    >
      <div className="product-card-header">
        {getProductTypeIcon(product.typeKey)} {/* Use mapped type key for icon */}
        <h3>{product.name}</h3> {/* Use mapped name */}
        <button
            className="expand-toggle-btn"
            aria-label={isSelected ? "Réduire les détails du produit" : "Afficher les détails du produit"}
            title={isSelected ? "Réduire" : "Afficher plus"}
        >
            {isSelected ? <FiChevronUp size={20}/> : <FiChevronDown size={20} />}
        </button>
      </div>
      <p className="product-meta-info text-secondary">Numéro de série : {product.serial}</p> {/* Use mapped serial */}

      {/* Expanded Details Section - Renders conditionally */}
      {isSelected && (
        <div className="product-details-expanded">
          <div className="detail-item">
            <strong>Date d'achat :</strong>
            <span>{product.purchaseDate || 'N/A'}</span> {/* Use mapped date */}
          </div>
          <div className="detail-item">
            <strong>Expiration de la garantie :</strong>
            <span>{product.warrantyExpiration || 'N/A'}</span> {/* Use mapped expiry */}
          </div>
          <div className="detail-item">
            <strong>Statut de la Garantie :</strong>
            {/* Use mapped status details for badge */}
            <span className={`warranty-status-badge status-${warrantyStatus.cssClass}`}>
              {warrantyStatus.text}
            </span>
          </div>

          {/* Displaying product specifications if available in the DB or fetched */}
          {/* Assuming 'specifications' would be fetched if it existed and mapped */}
          {/* product.specifications && Object.entries(product.specifications).map(([key, value]) => (
            <div className="detail-item" key={key}>
                <strong>{key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}:</strong>
                <span>{String(value)}</span>
            </div>
          ))*/}
           {/* Added a placeholder if no specs */}
            {!product.specifications && (
                 <div className="detail-item">
                     <strong>Spécifications :</strong>
                     <span>Non disponibles</span>
                 </div>
            )}


          {/* Action buttons */}
          <div className="product-card-actions">
            <Link
                to={`/customer/warranty-products/${product.id}`} // Link to a specific warranty detail page? Or general warranty page?
                className="btn btn-secondary btn-sm"
                onClick={(e) => e.stopPropagation()} // Prevent card click when button is clicked
                 title="Consulter les détails de la garantie"
            >
                <FiInfo size={14} style={{marginRight: '6px'}}/> Détails Garantie
            </Link>
            <button
                onClick={handleViewProductProblems} // This button filters problems by product serial
                className="btn btn-primary btn-sm"
                 title={`Voir les problèmes signalés pour ${product.serial}`}
            >
              <FiAlertTriangle size={14} style={{marginRight: '6px'}}/> Voir les Problèmes
            </button>
          </div>
        </div>
      )}
    </div>
  );
};


const MyProductsPage = () => {
  const [activeFilterKey, setActiveFilterKey] = useState('all');
  const [allUserProducts, setAllUserProducts] = useState([]); // Store all products fetched from DB
  const [filteredProducts, setFilteredProducts] = useState([]);
  // Products with active problems tracked by their *serial number* for filtering on this page
  const [productsWithActiveProblems, setProductsWithActiveProblems] = useState(new Set());
  const [selectedProductId, setSelectedProductId] = useState(null); // ID of the currently expanded product (using customer_product id)
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);


  // Fetch user products AND problems to determine active status on products
  useEffect(() => {
    const fetchData = async () => {
      setIsLoading(true);
      setError(null); // Clear previous errors

      const { data: { user: authUser }, error: authError } = await supabase.auth.getUser();
      if (authError || !authUser) {
        // If user is not logged in, ProtectedRoute should ideally redirect.
        // This is a fallback message.
        setError("Vous devez être connecté pour voir vos produits.");
        setIsLoading(false);
        return;
      }

       try {
         // 1. Fetch user's products from customer_product
         // --- This query expects: ---
         // --- 1. customer_product columns: id, serie_number, produc_name, "Purchase Date" (with space), "Warranty Expiration" (with space), status_warranty, produt_id (with typo) ---
         // --- 2. A Foreign Key relationship from customer_product.produt_id (with typo) to products.id ---
         // --- 3. The 'products' table to have a column named 'type' ---
         // --- If any of these are not met in your DB schema, the query will fail. ---
         const { data: productsData, error: productsError } = await supabase
             .from('customer_product')
             // --- CORRECTED SELECT STRING - ALL COMMENTS REMOVED ---
             .select(`
                id,
                serie_number,
                produc_name,
                "Purchase Date",
                "Warranty Expiration",
                status_warranty,
                produt_id,
                products (type)
             `)
             .eq('customer_id', authUser.id) // Filter by logged-in user's UUID
             .order('"Purchase Date"', { ascending: false }); // Order using double quotes if column name has space

          if (productsError) {
              console.error("Error fetching user products:", productsError);
              // Display the specific error message from Supabase/PostgREST
              setError(`Impossible de charger vos produits enregistrés. Détail: ${productsError.message}`);
              setAllUserProducts([]); // Clear products list on error
          } else {
              console.log("Fetched products:", productsData);
               // Map DB data to component friendly format, handling potential nulls and quoting
              const mappedProducts = productsData.map(p => ({
                  id: p.id, // customer_product ID
                  serial: p.serie_number || 'N/A',
                  name: p.produc_name || 'Nom non défini', // Use user's custom name
                  purchaseDate: p["Purchase Date"] ? new Date(p["Purchase Date"]).toLocaleDateString('fr-FR') : 'Date inconnue', // Access with bracket notation and quotes
                  warrantyExpiration: p["Warranty Expiration"] ? new Date(p["Warranty Expiration"]).toLocaleDateString('fr-FR') : 'Date inconnue', // Access with bracket notation and quotes
                  statusKey: p.status_warranty || 'unknown', // DB status value (e.g., 'active', 'expired', 'under warranty')
                  status: WARRANTY_STATUS_MAPPING[p.status_warranty?.toLowerCase()]?.text || WARRANTY_STATUS_MAPPING['unknown'].text, // Map DB status to display text
                  typeKey: p.products?.type?.toLowerCase() || 'other', // Get type from joined products table, lowercase for mapping
                  produtId: p.produt_id, // Keep the raw product_id (with typo) for linking if needed
                  // Map specification fields here if they were fetched
                  // specifications: p.specifications
               }));
              setAllUserProducts(mappedProducts); // Store the full list
          }

           // 2. Fetch user's problems to determine which products have active problems
           // Fetching tickets filtered by customer_id and active statuses
           // We need the customer_product serial numbers associated with these tickets
           // This query requires customer_tickets.product_id -> customer_product.id FK
           const { data: problemsData, error: problemsError } = await supabase
               .from('customer_tickets')
               .select(`customer_product (serie_number)`) // Select the joined serial numbers
               .eq('customer_id', authUser.id) // Filter by user
               // Filter for active statuses (ensure these match your DB status_problem values)
               .in('status_problem', ['pending', 'inprogress', 'planned']);

           if (problemsError) {
              console.error("Error fetching active problems for product status:", problemsError);
               // Don't block page load, just treat all products as having no active problems status
               setProductsWithActiveProblems(new Set()); // Ensure it's an empty set on error
           } else {
               console.log("Fetched active problems for products:", problemsData);
                // Collect serial numbers from the fetched problems
                // problemsData will be like [{ customer_product: { serie_number: 'XYZ' }}, ...]
                const serials = new Set(problemsData
                    .map(p => p.customer_product?.serie_number) // Get the serial number from the joined data
                    .filter(serial => serial)); // Filter out any null/undefined serials
               setProductsWithActiveProblems(serials);
           }

       } catch (err) {
          console.error("Unexpected error fetching products or problems:", err);
          setError("Une erreur inattendue s'est produite lors du chargement de vos produits.");
           setAllUserProducts([]);
           setProductsWithActiveProblems(new Set());
       } finally {
          setIsLoading(false);
       }
    };

    // Refetch if auth user changes? Or handle with auth state listener? Runs once on mount.
    fetchData();

  }, []); // Empty dependency array

   // Effect to apply filtering when filter key or products change
   useEffect(() => {
      let productsToShow = allUserProducts; // Start with all products

      // 1. Apply Type Filter (if not 'all' or 'active_problem')
      if (activeFilterKey !== 'all' && activeFilterKey !== 'active_problem') {
         productsToShow = productsToShow.filter(product =>
             product.typeKey === activeFilterKey.toLowerCase() // Filter by mapped type key
         );
      }

       // 2. Apply Active Problem Filter (if key is 'active_problem')
      if (activeFilterKey === 'active_problem') {
          productsToShow = productsToShow.filter(product =>
             // Check if the product's serial is in the set of serials with active problems
             productsWithActiveProblems.has(product.serial)
         );
      }

      // 3. Sort Products (e.g., alphabetically by name, or by purchase date)
      // Sort by purchase date (descending) as in the fetch query
      productsToShow.sort((a, b) => {
         // Access original date string using bracket notation and quotes for sorting
         const dateA = a["Purchase Date"] ? new Date(a["Purchase Date"]).getTime() : 0;
         const dateB = b["Purchase Date"] ? new Date(b["Purchase Date"]).getTime() : 0;
         return dateB - dateA; // Descending sort
      });


      setFilteredProducts(productsToShow);
      setSelectedProductId(null); // Collapse any open product when the filter changes

      // Re-filter whenever:
      // - the main product list (`allUserProducts`) changes
      // - the active filter key (`activeFilterKey`) changes
      // - the set of products with active problems (`productsWithActiveProblems`) changes
   }, [activeFilterKey, allUserProducts, productsWithActiveProblems]);


   // Calculate counts for tabs based on *allUserProducts* and *productsWithActiveProblems*
   // Recalculates whenever the main product list or the active problems set changes
   const productCounts = useMemo(() => {
     return productFilterTabsConfig.reduce((acc, tab) => {
       if (tab.key === 'all') {
         acc[tab.key] = allUserProducts.length;
       } else if (tab.key === 'active_problem') {
         // Count products whose serial is in the set of products with active problems
         acc[tab.key] = allUserProducts.filter(p => productsWithActiveProblems.has(p.serial)).length;
       } else { // Filter by type (like 'tv', 'smartphone') using the mapped typeKey
         acc[tab.key] = allUserProducts.filter(p => p.typeKey === tab.key.toLowerCase()).length;
       }
       return acc;
     }, {});
   }, [allUserProducts, productsWithActiveProblems]);


  const handleSelectProduct = (productId) => {
    setSelectedProductId(prevSelectedId => (prevSelectedId === productId ? null : productId));
  };

  // Render loading state while data is being fetched
  if (isLoading) {
     return (
         <div className="my-products-page fade-in-up">
              <div className="page-header">
                <h1>Chargement...</h1>
                <p className="text-secondary">Chargement de vos produits.</p>
              </div>
              {/* Optional: Add a spinner */}
           </div>
      );
  }

   // Render error state if fetching failed
   if (error) {
      return (
         <div className="my-products-page fade-in-up">
              <div className="page-header">
                <h1>Erreur</h1>
                <p className="text-secondary">Impossible de charger vos produits.</p>
              </div>
              <div className="custom-card auth-message error" style={{ maxWidth: '600px', margin: '20px auto' }}>
                <p>{error}</p>
                 {/* If the error message suggests authentication is required */}
                 {error.includes("connecté") && ( // Simple check for the authentication message
                     <Link to="/login" className="btn btn-primary" style={{marginTop: '15px'}}>Se connecter</Link>
                 )}
             </div>
           </div>
      );
   }


  return (
    <div className="my-products-page fade-in-up">
      {/* Page Header */}
      <div className="page-header">
        <h1>Mes Produits</h1>
        <p className="text-secondary">Consultez et gérez vos produits BOMARE enregistrés.</p>
      </div>

      {/* Filter Tabs */}
      <div className="product-filters-container">
        {productFilterTabsConfig.map(tab => (
          <button
            key={tab.key}
            className={`product-filter-btn ${activeFilterKey === tab.key ? 'active' : ''}`}
            onClick={() => setActiveFilterKey(tab.key)}
            aria-pressed={activeFilterKey === tab.key}
             disabled={isLoading} // Disable tabs while loading
          >
            {tab.icon && <span className="filter-btn-icon">{tab.icon}</span>}
            {tab.label} ({productCounts[tab.key] || 0})
          </button>
        ))}
      </div>

      {/* List of Product Cards */}
      <div className="products-list-main-container">
        {filteredProducts.length > 0 ? (
          // Render a card for each filtered product
          filteredProducts.map(product => (
            <ProductCard
              key={product.id} // Use database ID of customer_product entry as the key
              product={product}
              onSelectProduct={handleSelectProduct}
              isSelected={selectedProductId === product.id}
            />
          ))
        ) : (
          // Message shown when the filtered list is empty
          <div className="custom-card no-products-message-alt">
            <p className="text-secondary">
              Aucun produit trouvé pour "{productFilterTabsConfig.find(t => t.key === activeFilterKey)?.label || 'cette catégorie'}".
               {allUserProducts.length > 0 && activeFilterKey !== 'all' && ( // If there are products but not in this filter
                   " Veuillez ajuster vos filtres."
               )}
            </p>
            {/* Button to register a new product */}
            {/* UPDATED LINK: Points to the registration form page */}
            <Link to="/customer/register-product" className="btn btn-primary btn-icon" disabled={isLoading}> {/* Link to registration page */}
              <FiPlusCircle size={18} style={{ marginRight: '6px' }} /> Enregistrer un nouveau produit
            </Link>
             {/* Option to view all products if a filter is active */}
             {activeFilterKey !== 'all' && allUserProducts.length > 0 && (
                 <button className="btn btn-secondary" style={{marginTop: '10px'}} onClick={() => setActiveFilterKey('all')} disabled={isLoading}>
                     Voir tous mes produits
                 </button>
             )}
          </div>
        )}
      </div>

       {/* "Ajouter un Autre Produit" button at the bottom - remains separate */}
        <div className="add-product-button-container" style={{marginTop: '40px'}}>
             {/* UPDATED LINK: Points to the registration form page */}
            <Link to="/customer/register-product" className="btn btn-primary btn-icon btn-lg" disabled={isLoading}>
              <FiPlusCircle size={18} style={{ marginRight: '8px' }} /> Enregistrer un Autre Produit
            </Link>
         </div>
    </div>
  );
};

export default MyProductsPage;
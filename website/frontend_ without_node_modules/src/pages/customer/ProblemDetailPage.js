// src/pages/customer/ProblemDetailPage.js
import React, { useState, useEffect } from 'react';
import { useParams, Link, useNavigate } from 'react-router-dom';
import { FiArrowLeft, FiMessageSquare, FiPaperclip, FiUser, FiClock } from 'react-icons/fi';
import { supabase } from '../../supabaseClient';
import './ProblemDetailPage.css'; // You'll need to create this CSS file

// Re-use or redefine STATUS_MAPPING (ensure it's consistent with MyProblems.js)
const STATUS_MAPPING = {
    'Pending':    { key: 'Pending',    label: 'En Attente', cssClass: 'pending',    text: 'En attente de réponse' },
    'inprogress': { key: 'inprogress', label: 'Ouvert',     cssClass: 'inprogress', text: 'En cours de traitement' },
    'planned':    { key: 'planned',    label: 'Ouvert',     cssClass: 'inprogress', text: 'Planifié' },
    'Resolved':   { key: 'Resolved',   label: 'Résolu',     cssClass: 'resolved',   text: 'Résolu' },
    'closed':     { key: 'closed',     label: 'Clôturé',    cssClass: 'closed',     text: 'Clôturé' },
    'expired':    { key: 'expired',    label: 'Expiré',     cssClass: 'expired',    text: 'Expiré'},
    'unknown':    { key: 'unknown',    label: 'Inconnu',    cssClass: 'unknown',    text: 'Statut Inconnu' },
};

const ProblemDetailPage = () => {
  const { problemId } = useParams();
  const navigate = useNavigate();
  const [problem, setProblem] = useState(null);
  // const [messages, setMessages] = useState([]); // If you have a messages/comments system
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);
  const [authUser, setAuthUser] = useState(null);

  useEffect(() => {
    let isMounted = true;

    const fetchDetails = async () => {
      if (!isMounted) return;
      setIsLoading(true);
      setError(null);

      // 1. Get authenticated user
      const { data: { user }, error: userError } = await supabase.auth.getUser();
      if (!isMounted) return;

      if (userError || !user) {
        console.error("ProblemDetailPage: Auth error or no user", userError);
        setError("Authentification requise pour voir les détails.");
        setIsLoading(false);
        setAuthUser(null);
        // Optional: navigate to login if not using ProtectedRoute strictly
        // navigate('/login');
        return;
      }
      setAuthUser(user);

      // 2. Fetch problem details
      try {
        console.log(`Fetching problem ID: ${problemId} for user ID: ${user.id}`);
        const { data: problemData, error: problemFetchError } = await supabase
          .from('customer_tickets')
          .select(`
            id,
            problem,
            status_problem,
            created_at,
            updated_at,
            category,
            customer_id,
            customer_product (
                id,
                serie_number,
                produc_name,
                products (
                    product_name,
                    type
                )
            )
          `)
          .eq('id', problemId)
          .eq('customer_id', user.id) // IMPORTANT: Ensure user can only see their own tickets
          .single();

        if (!isMounted) return;

        if (problemFetchError) {
          console.error("Error fetching problem details:", problemFetchError);
          if (problemFetchError.code === 'PGRST116') { // PostgREST error for "No rows found"
            setError(`Problème N°${problemId} non trouvé ou accès non autorisé.`);
          } else {
            setError(`Impossible de charger les détails du problème: ${problemFetchError.message}`);
          }
          setProblem(null);
        } else if (problemData) {
          console.log("Problem data fetched:", problemData);
          const statusDetails = STATUS_MAPPING[problemData.status_problem] || STATUS_MAPPING['unknown'];
          setProblem({
            ...problemData,
            // Map additional fields for display
            productName: problemData.customer_product?.products?.product_name || problemData.customer_product?.produc_name || 'Produit inconnu',
            productSerial: problemData.customer_product?.serie_number || 'N/A',
            productType: problemData.customer_product?.products?.type || 'N/A',
            statusLabel: statusDetails.label,
            statusClass: statusDetails.cssClass,
            formattedCreatedAt: new Date(problemData.created_at).toLocaleString('fr-FR'),
            formattedUpdatedAt: problemData.updated_at ? new Date(problemData.updated_at).toLocaleString('fr-FR') : 'N/A',
          });

          // TODO: Fetch messages/updates for this ticket if you have a separate table
          // e.g., from 'ticket_updates' or 'ticket_messages'
        } else {
           // This case might be redundant if .single() throws PGRST116 for no rows
          setError(`Problème N°${problemId} non trouvé.`);
          setProblem(null);
        }
      } catch (catchError) {
        if (isMounted) {
          console.error("Unexpected error in fetchDetails:", catchError);
          setError("Une erreur inattendue est survenue lors du chargement des détails.");
          setProblem(null);
        }
      } finally {
        if (isMounted) setIsLoading(false);
      }
    };

    if (problemId) { // Only fetch if problemId is available
        fetchDetails();
    } else {
        setError("ID du problème non spécifié.");
        setIsLoading(false);
    }


    return () => {
      isMounted = false;
    };
  }, [problemId]); // Re-fetch if problemId changes

  if (isLoading) {
    return (
      <div className="problem-detail-page-loading">
        <h2>Vérification des Accès...</h2>
        <p>Veuillez patienter.</p>
        <div className="loading-spinner-detail"></div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="problem-detail-page fade-in-up">
        <div className="page-header">
          <h1>Erreur</h1>
        </div>
        <div className="custom-card error-card">
          <p className="text-danger">{error}</p>
          <Link to="/customer/my-problems" className="btn btn-secondary" style={{ marginTop: '20px' }}>
            <FiArrowLeft style={{ marginRight: '8px' }} /> Retour à Mes Problèmes
          </Link>
        </div>
      </div>
    );
  }

  if (!problem) {
    // This case should ideally be caught by error handling, but as a fallback:
    return (
      <div className="problem-detail-page fade-in-up">
        <div className="page-header">
          <h1>Problème Non Trouvé</h1>
        </div>
        <div className="custom-card info-card">
          <p>Les détails pour ce problème n'ont pas pu être chargés.</p>
          <Link to="/customer/my-problems" className="btn btn-secondary" style={{ marginTop: '20px' }}>
            <FiArrowLeft style={{ marginRight: '8px' }} /> Retour à Mes Problèmes
          </Link>
        </div>
      </div>
    );
  }

  return (
    <div className="problem-detail-page fade-in-up">
      <div className="page-header">
        <h1>Détails du Problème N°{problem.id}</h1>
        <button onClick={() => navigate(-1)} className="btn btn-secondary btn-sm btn-icon page-header-action-btn">
            <FiArrowLeft /> Retour
        </button>
      </div>

      <div className="problem-detail-container">
        <div className="custom-card problem-summary-card">
          <h2>{problem.problem.substring(0,100) || `Problème avec ${problem.productName}`}</h2>
          <div className={`status-badge-detail status-detail-${problem.statusClass}`}>
            {problem.statusLabel}
          </div>
          <div className="problem-meta-grid">
            <div><strong>Produit :</strong> {problem.productName} ({problem.productType})</div>
            <div><strong>Numéro de série :</strong> {problem.productSerial}</div>
            <div><strong>Catégorie :</strong> {problem.category || 'Non spécifiée'}</div>
            <div><strong>Signalé le :</strong> {problem.formattedCreatedAt}</div>
            <div><strong>Dernière mise à jour :</strong> {problem.formattedUpdatedAt}</div>
          </div>
        </div>

        <div className="custom-card problem-description-card">
          <h3>Description complète du problème :</h3>
          <p className="text-secondary">{problem.problem}</p>
        </div>

        {/* Placeholder for attached files - TODO: Implement file display logic */}
        {/* {problem.attachments && problem.attachments.length > 0 && (
          <div className="custom-card problem-attachments-card">
            <h3><FiPaperclip /> Pièces jointes :</h3>
            <ul>
              {problem.attachments.map(file => (
                <li key={file.id}><a href={file.url} target="_blank" rel="noopener noreferrer">{file.name}</a></li>
              ))}
            </ul>
          </div>
        )} */}

        <div className="custom-card problem-timeline-card">
          <h3><FiMessageSquare /> Historique et Mises à jour :</h3>
          {/* TODO: Replace with actual messages/timeline data */}
          {/* {messages.length > 0 ? (
            messages.map(msg => (
              <div key={msg.id} className="timeline-item">
                <div className="timeline-actor"><FiUser /> {msg.actor || 'Support'}</div>
                <div className="timeline-time"><FiClock /> {new Date(msg.created_at).toLocaleString('fr-FR')}</div>
                <p>{msg.content}</p>
              </div>
            ))
          ) : ( */}
            <p className="text-secondary">Aucune mise à jour ou message pour le moment.</p>
          {/* )} */}
        </div>

        {/* Placeholder for actions like adding a new message */}
        {/* <div className="custom-card problem-actions-card">
          <h3>Ajouter un message</h3>
          <textarea placeholder="Votre message..." rows="4"></textarea>
          <button className="btn btn-primary" style={{marginTop: '10px'}}>Envoyer</button>
        </div> */}

      </div>
    </div>
  );
};

export default ProblemDetailPage;
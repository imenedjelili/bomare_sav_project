
// src/pages/customer/RegisterProductPage.js
import React, { useState, useEffect } from 'react';
// Import Link and useNavigate from react-router-dom
import { Link, useNavigate } from 'react-router-dom';
// Import FiSave, FiArrowLeft, and FiPlus from react-icons/fi
import { FiSave, FiArrowLeft, FiPlus } from 'react-icons/fi';
import { supabase } from '../../supabaseClient';
import './RegisterProductPage.css'; // We will create this CSS file

const RegisterProductPage = () => {
  const navigate = useNavigate(); // Declare navigate hook first

  // State for form inputs - Declare state variables at the top
  const [serialNumber, setSerialNumber] = useState('');
  const [purchaseDate, setPurchaseDate] = useState('');
  const [producName, setProducName] = useState('');
  const [selectedProdutId, setSelectedProdutId] = useState('');

  // State for fetching user and product catalog
  const [user, setUser] = useState(null);
  const [availableProducts, setAvailableProducts] = useState([]);
  const [isLoadingUser, setIsLoadingUser] = useState(true);
  const [isLoadingProducts, setIsLoadingProducts] = useState(true);

  // State for form submission feedback
  const [formMessage, setFormMessage] = useState('');
  const [isFormSuccess, setIsFormSuccess] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState(null); // General page error (e.g., failed fetches)


  // Fetch logged-in user on mount
  useEffect(() => {
    const fetchUser = async () => {
      setIsLoadingUser(true);
      const { data: { user: authUser }, error: authError } = await supabase.auth.getUser();

      if (authError || !authUser) {
        console.error("User not logged in:", authError);
        // ProtectedRoute should handle redirect, but set state defensively
        setError("Vous devez être connecté pour enregistrer un produit.");
        setUser(null);
      } else {
        setUser(authUser);
      }
      setIsLoadingUser(false); // Ensure loading state is turned off
    };

    fetchUser();
  }, []);


  // Fetch available product models from the 'products' catalog table
  useEffect(() => {
    const fetchProducts = async () => {
      setIsLoadingProducts(true);
      setError(null); // Clear previous errors for this fetch

      try {
        const { data: productsData, error: productsError } = await supabase
          .from('products')
          .select('id, product_name')
          .order('product_name', { ascending: true });

        if (productsError) {
          console.error("Error fetching product catalog:", productsError);
          setError(`Impossible de charger la liste des produits disponibles: ${productsError.message}`);
          setAvailableProducts([]);
        } else {
          console.log("Fetched product catalog:", productsData);
          setAvailableProducts(productsData);
        }
      } catch (err) {
         console.error("Unexpected error fetching product catalog:", err);
         setError("Une erreur inattendue s'est produite lors du chargement des produits.");
         setAvailableProducts([]);
      } finally {
        setIsLoadingProducts(false); // Ensure loading state is turned off
      }
    };

    fetchProducts();
  }, []); // Empty dependency array means this runs once on mount


  // Derived state for overall loading
  const overallLoading = isLoadingUser || isLoadingProducts;

  // Derived state for form disabled status - MUST be declared AFTER the states it depends on
  const isFormDisabled = isSubmitting || overallLoading || !user || availableProducts.length === 0;


  // --- DEBUGGING EFFECT (Added in previous step) ---
  // This effect should run AFTER all state/hook declarations
  useEffect(() => {
    if (!overallLoading) {
      console.log("RegisterProductPage: Loading Finished");
      console.log("User:", user);
      console.log("Available Products:", availableProducts);
      console.log("Available Products Length:", availableProducts.length);
      console.log("Error state:", error);
      console.log("isSubmitting:", isSubmitting);
      console.log("isFormDisabled calculated:", isFormDisabled); // Use the derived state variable here
    }
  }, [overallLoading, user, availableProducts, error, isSubmitting, isFormDisabled]); // Add isFormDisabled to deps


  // Handle form submission - Declare handleSubmit function after state/hooks
  const handleSubmit = async (e) => {
    e.preventDefault();
    setFormMessage('');
    setIsFormSuccess(false);

    // Client-side validation
    if (!serialNumber.trim() || !purchaseDate || !selectedProdutId) {
      setFormMessage("Veuillez remplir tous les champs obligatoires (Numéro de série, Date d'achat, et Produit).");
      setIsFormSuccess(false);
      return; // Stop submission
    }

    if (!user) {
         // This case should ideally be prevented by isFormDisabled, but defensive check
         setFormMessage("Erreur: Informations utilisateur non disponibles. Veuillez vous reconnecter.");
         setIsFormSuccess(false);
         return;
    }

    setIsSubmitting(true);

    try {
      const { data, error: insertError } = await supabase
        .from('customer_product')
        .insert({
           serie_number: serialNumber.trim(),
           produc_name: producName.trim() || null,
           "Purchase Date": purchaseDate,
           produt_id: parseInt(selectedProdutId, 10),
           customer_id: user.id,
        })
        .select();

      if (insertError) {
        console.error("Supabase Product Registration Error:", insertError);
        setFormMessage(`Échec de l\'enregistrement du produit : ${insertError.message}`);
        setIsFormSuccess(false);
      } else {
        console.log("Product registered successfully:", data);
        setFormMessage("Produit enregistré avec succès !");
        setIsFormSuccess(true);
        // Clear the form after successful submission
        setSerialNumber('');
        setPurchaseDate('');
        setProducName('');
        setSelectedProdutId('');
      }

    } catch (err) {
      console.error("Unexpected error during product registration:", err);
      setFormMessage('Une erreur inattendue s\'est produite. Veuillez réessayer.');
      setIsFormSuccess(false);
    } finally {
      setIsSubmitting(false);
    }
  };


  // --- Render Logic ---

  // Show loading state for initial data fetches
  if (overallLoading) {
    return (
      <div className="register-product-page fade-in-up">
         <div className="page-header">
            <h1>Enregistrer un Produit</h1>
            <p className="text-secondary">Chargement des données requises...</p>
         </div>
      </div>
    );
  }

   // Show error state if initial fetches failed
   if (error) {
       return (
           <div className="register-product-page fade-in-up">
              <div className="page-header">
                <h1>Erreur</h1>
                <p className="text-secondary">Impossible d'afficher la page d'enregistrement.</p>
              </div>
               <div className="custom-card auth-message error" style={{ maxWidth: '600px', margin: '20px auto' }}>
                 <p>{error}</p>
                 {/* If the error message suggests authentication is required */}
                 {error.includes("connecté") && (
                     <Link to="/login" className="btn btn-primary" style={{marginTop: '15px'}}>Se connecter</Link>
                 )}
                 {/* Add a button to retry loading if it was a fetch error */}
                 {!error.includes("connecté") && (
                      <button onClick={() => window.location.reload()} className="btn btn-secondary" style={{marginTop: '15px'}}>
                          Réessayer
                      </button>
                 )}
              </div>
           </div>
       );
   }

    // Render "Not Logged In" state (Should be caught by ProtectedRoute, but defensive)
   if (!user) {
         return (
             <div className="register-product-page fade-in-up">
                <div className="page-header">
                   <h1>Accès Refusé</h1>
                   <p className="text-secondary">Veuillez vous connecter pour enregistrer un produit.</p>
                </div>
                 <div className="custom-card auth-message error" style={{ maxWidth: '600px', margin: '20px auto' }}>
                     <p>Vous n'êtes pas connecté.</p>
                     <Link to="/login" className="btn btn-primary" style={{marginTop: '15px'}}>Se connecter</Link>
                 </div>
              </div>
         );
   }


  // Render the form once data is loaded, no errors, and user is authenticated
  return (
    <div className="register-product-page fade-in-up">
      <div className="page-header">
        <h1>Enregistrer un Produit</h1>
        <p className="text-secondary">Enregistrez un nouveau produit BOMARE que vous possédez.</p>
      </div>

      {/* Form Container */}
      <div className="register-form-container">

         {/* Success or Error Message */}
         {formMessage && (
            <p className={`form-message ${isFormSuccess ? 'success' : 'error'}`}>
              {formMessage}
            </p>
         )}

        {/* Registration Form */}
         {/* Only show the form fields if NOT successful, OR if it was a submission error */}
         {(!isFormSuccess || formMessage.includes('Échec')) && (
            <form onSubmit={handleSubmit} className="product-registration-form">
              {/* Product Select */}
              <div className="form-group">
                <label htmlFor="productSelect" className="label">Produit <span className="required">*</span></label>
                <select
                  id="productSelect"
                  className="input-field" // Reuse input styles or create a select-field style
                  value={selectedProdutId}
                  onChange={(e) => setSelectedProdutId(e.target.value)}
                  required
                  // Disable if form is disabled OR specifically if product list is empty
                  // Using isFormDisabled here covers overallLoading, !user, and isSubmitting
                  disabled={isFormDisabled || availableProducts.length === 0}
                >
                  <option value="">-- Sélectionnez un produit --</option>
                  {availableProducts.map(product => (
                    <option key={product.id} value={product.id}>
                      {product.product_name}
                    </option>
                  ))}
                </select>
                 {/* Message if no products available */}
                 {availableProducts.length === 0 && !overallLoading && !error && ( // Show only when loaded, no error, and list is empty
                     <p className="text-secondary" style={{marginTop: '5px', fontSize: '0.9em'}}>
                        Aucun produit disponible à la sélection.
                     </p>
                 )}
              </div>

              {/* Serial Number */}
              <div className="form-group">
                <label htmlFor="serialNumber" className="label">Numéro de Série <span className="required">*</span></label>
                <input
                  type="text"
                  id="serialNumber"
                  className="input-field"
                  value={serialNumber}
                  onChange={(e) => setSerialNumber(e.target.value)}
                  placeholder="Entrez le numéro de série"
                  required
                  disabled={isFormDisabled}
                />
              </div>

               {/* Purchase Date */}
              <div className="form-group">
                <label htmlFor="purchaseDate" className="label">Date d'Achat <span className="required">*</span></label>
                <input
                  type="date"
                  id="purchaseDate"
                  className="input-field"
                  value={purchaseDate}
                  onChange={(e) => setPurchaseDate(e.target.value)}
                  required
                  disabled={isFormDisabled}
                  // Optional: Set max date to today
                  max={new Date().toISOString().split('T')[0]}
                />
              </div>

              {/* User-defined Product Name (Optional) */}
               <div className="form-group">
                <label htmlFor="producName" className="label">Nom Personnalisé du Produit (Optionnel)</label>
                <input
                  type="text"
                  id="producName"
                  className="input-field"
                  value={producName}
                  onChange={(e) => setProducName(e.target.value)}
                  placeholder="Ex: Ma télé du salon"
                  disabled={isFormDisabled}
                />
              </div>

              {/* Submit Button */}
              <div className="form-actions">
                <button type="submit" className="btn btn-primary btn-icon" disabled={isFormDisabled}>
                  {isSubmitting ? (
                    <>
                      <FiSave /> Enregistrement...
                    </>
                  ) : (
                    <>
                       <FiSave /> Enregistrer le Produit
                    </>
                  )}
                </button>
              </div>
            </form>
         )}

          {/* Show a confirmation/next step block on success */}
          {isFormSuccess && !formMessage.includes('Échec') && (
               <div className="success-feedback" style={{textAlign: 'center', padding: '40px 20px'}}>
                  <p>Votre produit a été enregistré avec succès !</p>
                   <p style={{marginTop: '15px'}}>
                       <button
                            className="btn btn-secondary btn-icon"
                            onClick={() => navigate('/customer/my-products')} // Go back to My Products page
                            style={{ marginRight: '10px' }}
                            disabled={isSubmitting} // Disable buttons while submitting (though success state implies not submitting)
                        >
                           <FiArrowLeft style={{ marginRight: '6px' }}/> Voir mes produits
                        </button>
                        <button
                             className="btn btn-primary btn-icon"
                             onClick={() => {
                                // Reset form state to register another product
                                setFormMessage('');
                                setIsFormSuccess(false);
                                setSerialNumber('');
                                setPurchaseDate('');
                                setProducName('');
                                setSelectedProdutId('');
                             }}
                             disabled={isSubmitting} // Disable buttons while submitting
                        >
                           <FiPlus style={{ marginRight: '6px' }}/> Enregistrer un autre produit
                        </button>
                   </p>
               </div>
          )}

      </div>
    </div>
  );
};

export default RegisterProductPage;
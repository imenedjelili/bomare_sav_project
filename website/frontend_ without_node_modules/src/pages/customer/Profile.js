// src/pages/customer/Profile.js
import React, { useState, useEffect } from 'react';
import { FiEdit, FiSave, FiXCircle } from 'react-icons/fi';
// Removed mockUser as we will fetch from Supabase
import { supabase } from '../../supabaseClient'; // Import supabase client
import './Profile.css'; // Page-specific styles

const Profile = () => {
  // State for user data fetched from DB (what's currently "saved")
  // Initialize as null to indicate no data loaded yet
  const [user, setUser] = useState(null);
  // formData should store the values currently in the form fields during editing
  // Initialize as null/empty structure
  const [formData, setFormData] = useState(null);

  // State for controlling the form editing mode
  const [isEditing, setIsEditing] = useState(false);
  // State for loading status while fetching data
  const [isLoading, setIsLoading] = useState(true);
  // State for saving status while updating data
  const [isSaving, setIsSaving] = useState(false);
  // State for handling errors (fetch or save)
  const [error, setError] = useState(null);

  // --- Function to fetch profile data ---
  const fetchProfile = async () => {
      setIsLoading(true);
      setError(null); // Clear previous errors

      try {
          // Get the currently authenticated user
          const { data: { user: authUser }, error: authError } = await supabase.auth.getUser();

          if (authError || !authUser) {
              // This case should theoretically be caught by ProtectedRoute,
              // but handle it gracefully just in case (e.g., session expired).
              console.error("No authenticated user found on Profile page:", authError?.message);
              // Optionally redirect to login or show a login prompt
              setError("Authentification requise ou session expirée.");
              setIsLoading(false);
              return;
          }

          const userId = authUser.id; // Get the user's unique ID

          // 1. Fetch data from the 'Users' table
          const { data: userData, error: userError } = await supabase
              .from('Users') // Your public 'Users' table
              .select('first_name, last_name, email, phone_number')
              .eq('id', userId) // Filter by the authenticated user's ID
              .single(); // Expecting exactly one row for this user

          if (userError) {
              console.error("Error fetching user data:", userError);
              setError(`Échec du chargement des informations utilisateur: ${userError.message}`);
              setIsLoading(false);
              // Optionally sign out if user row is unexpectedly missing after auth
               if (userError.code === 'PGRST116') { // 406 error code for "No Rows" from .single()
                  console.warn("User row not found in 'Users' table for auth user ID:", userId, "- Initiating logout.");
                  await supabase.auth.signOut();
                  setError("Erreur critique: Votre profil utilisateur est introuvable. Vous avez été déconnecté.");
                  // Consider navigation to login page: navigate('/login', { replace: true });
               }
               return;
          }

           // Handle case where user exists but userData might still be null if not .single() and no row matched (less likely with eq('id', ...).single())
           if (!userData) {
                console.error("User data fetch returned null for ID:", userId);
                 setError("Échec du chargement des informations utilisateur: Données manquantes.");
                 setIsLoading(false);
                return;
           }

          // 2. Fetch data from the 'profile_customer' table
           // Note: Use 'customer_id' in profile_customer table to link to 'id' in Users table
          const { data: customerProfileData, error: customerProfileError } = await supabase
              .from('profile_customer') // Your public 'profile_customer' table
              .select('address')
              .eq('customer_id', userId) // Filter by the customer's user ID
              .single(); // Expecting at most one row per customer

          // Handle the case where a customer profile row might not exist yet
          // This could happen if a trigger wasn't set up or failed on signup
          // A 406 error (PGRST116) from `.single()` usually indicates no rows found
           let customerAddress = ''; // Default empty address if row doesn't exist
           if (customerProfileError && customerProfileError.code !== 'PGRST116') {
                console.error("Error fetching customer profile data:", customerProfileError);
                // Don't necessarily stop loading the main user data, but log the error and show a warning
                 setError(prevError => `${prevError ? prevError + ' / ' : ''} Échec du chargement des détails de profil: ${customerProfileError.message}`);
                // Still proceed if userData was fetched successfully, but address will be default ('')
           } else if (customerProfileData) {
                customerAddress = customerProfileData.address || ''; // Use address if fetched, default to empty string if address is null/empty
           }
            // If customerProfileError exists with code PGRST116, customerAddress remains '' as initialized


          // 3. Combine fetched data into a usable format
          const combinedProfileData = {
            // Note: We store firstName, lastName, email, phone (using DB column names for clarity in object)
            // ClientId might not be in DB directly, derive it or use authUser.id
            clientId: userId, // Use auth user ID as client ID identifier
            firstName: userData.first_name,
            lastName: userData.last_name,
            email: userData.email, // Should match auth email if verification happened
            phone: userData.phone_number, // Map DB phone_number to local 'phone'
            address: customerAddress, // Address from customer_profile table
             // Compute the full name for display directly in the object
            name: `${userData.first_name || ''} ${userData.last_name || ''}`.trim(),
          };

          console.log("Profile data fetched:", combinedProfileData);

          // Set both user and formData states with the fetched data
          setUser(combinedProfileData);
          setFormData({...combinedProfileData}); // Clone for editing
          setIsEditing(false); // Start in view mode
          setIsLoading(false); // Loading finished


      } catch (err) { // Catch unexpected errors during fetch process
          console.error("Unexpected error during profile fetch:", err);
           // Overwrite any specific errors if an unexpected one occurs
          setError('Une erreur inattendue s\'est produite lors du chargement du profil.');
          setUser(null); // Clear state on error
          setFormData(null);
          setIsLoading(false); // Stop loading regardless of error
      }
  };


  // --- useEffect to trigger fetching when component mounts ---
  useEffect(() => {
      // Add a cleanup flag to prevent setting state on an unmounted component
      let isMounted = true;

      fetchProfile().then(() => {
           if (isMounted) {
               // Initial focus setup - attempt to focus the edit button if user exists and not loading/editing
                if(user && !isLoading && !isEditing) {
                   // Find the edit button by its class/role or a specific ref if added
                    const editButton = document.querySelector('.profile-summary-card-styled .btn-secondary'); // Or use a ref
                    if(editButton) editButton.focus();
               } else if (!isLoading && (!user || error)) {
                   // If failed to load profile, maybe focus an error message or body
                   // This is less critical, usually focus management is for forms/interactions
               }
           }
       })
      .catch(err => { // Catch error if fetchProfile throws unhandled error (less likely with try/catch inside)
          if (isMounted) {
               console.error("Profile fetch promise rejected:", err);
              setError('Une erreur fatale est survenue lors du chargement.');
              setIsLoading(false);
          }
      });


      // Cleanup function
      return () => {
          isMounted = false;
      };
  }, [/* No dependencies - run only on mount for initial fetch */]); // Only run fetch on initial component mount


  // --- Handlers for UI interactions ---

  // No change needed, uses formData which is populated from fetch initially
  const handleEdit = () => {
    if (user) { // Ensure user data is loaded before allowing edit
        setFormData({...user}); // Initialize form with current user data
        setIsEditing(true);
        setError(null); // Clear errors when starting edit
         // Optional: Focus the first input field after entering edit mode
         setTimeout(() => { // Use timeout to allow DOM update
             document.getElementById('profileFirstName')?.focus();
         }, 0);
    } else {
         console.warn("Cannot enter edit mode: User data not loaded.");
         // Maybe provide feedback to the user
    }
  };

  // Revert formData to original user data and exit editing
  const handleCancel = () => {
     if (user) { // Ensure user data is loaded to revert to
         setFormData({...user}); // Revert form data to original user data
         setIsEditing(false);
          setError(null); // Clear errors when cancelling
          // Optional: Focus the Edit button after cancelling
         setTimeout(() => { // Use timeout to allow DOM update
             const editButton = document.querySelector('.profile-summary-card-styled .btn-secondary');
              if(editButton) editButton.focus();
         }, 0);
     } else {
         console.warn("Cannot cancel editing: User data not available to revert.");
          // If somehow cancelling without loaded user data, just exit editing state
          setIsEditing(false);
           setError(null);
     }
  };


  // Handles changes for all input fields (firstName, lastName, email, phone, address)
  // Correctly updates the combined formData structure.
  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prevData => {
      if (!prevData) return null; // Prevent updating null state if data not loaded
      const newData = { ...prevData, [name]: value };

      // If firstName or lastName is changed, update the composite 'name' property in formData for display
      if (name === "firstName") {
        newData.name = `${value} ${prevData.lastName || ''}`.trim();
      } else if (name === "lastName") {
        newData.name = `${prevData.firstName || ''} ${value}`.trim();
      }
      // No need to handle name updates for other fields (email, phone, address)
      return newData;
    });
  };

  // --- Function to save profile data to Supabase ---
  const handleSave = async () => {
      if (!formData || !user || !user.clientId) {
          console.warn("Cannot save: formData or user data is missing.");
          setError("Impossible d'enregistrer : données incomplètes.");
          return; // Prevent saving if data is not ready or no user ID
      }

      setIsSaving(true);
      setError(null); // Clear previous errors before saving attempt

      // Get the user ID from the initial user state (which came from auth)
      const userId = user.clientId;

      try {
          // 1. Update the 'Users' table
          console.log("Attempting to update Users table for user ID:", userId, formData);
          const { error: userUpdateError } = await supabase
              .from('Users')
              .update({
                  first_name: formData.firstName,
                  last_name: formData.lastName,
                  email: formData.email, // Note: Changing email might require re-verification by user if confirmation is on
                  phone_number: formData.phone // Map local 'phone' state to DB 'phone_number'
              })
              .eq('id', userId); // Ensure only updating the current user's row

          if (userUpdateError) {
              console.error("Supabase Users Update Error:", userUpdateError);
              // Keep form editable to allow user to correct/re-save
              setError(`Échec de la mise à jour des informations utilisateur: ${userUpdateError.message}`); // Provide Supabase error details for dev
              // For production, a more generic error message might be preferred: setError('Échec de la mise à jour des informations utilisateur. Veuillez réessayer.');
              setIsSaving(false);
              // Do NOT proceed to update profile_customer if Users update failed
              return;
          }
          console.log("Users table updated successfully.");

          // 2. Update the 'profile_customer' table
           console.log("Attempting to update profile_customer table for user ID:", userId, { address: formData.address });
          const { error: customerProfileUpdateError } = await supabase
              .from('profile_customer')
              .update({
                  address: formData.address
              })
              .eq('customer_id', userId); // Ensure only updating the current customer's profile row

          if (customerProfileUpdateError) {
               console.error("Supabase Customer Profile Update Error:", customerProfileUpdateError);
              setError(`Échec de la mise à jour de l\'adresse: ${customerProfileUpdateError.message}`); // Dev detail
               // setError('Échec de la mise à jour de l\'adresse. Veuillez réessayer.'); // Prod generic
              setIsSaving(false);
               // If user update succeeded but profile_customer failed, we have a partial save.
               // A robust system might handle this or retry. For now, we report the error.
               return;
          }
          console.log("profile_customer table updated successfully.");


          // If BOTH updates succeed
          // Update the main user state with the successfully saved data
          setUser({
             ...formData, // formData now contains the state after successful changes
             // Recompute name just in case, though handleChange should have kept it updated
             name: `${formData.firstName || ''} ${formData.lastName || ''}`.trim(),
             // Keep original clientId and any other properties not in formData but needed in user state
             clientId: user.clientId // Make sure clientId is retained if not in formData structure
          });

          setIsEditing(false); // Exit editing mode
          // Show success message
          alert("Profil mis à jour avec succès !"); // Replace with a more elegant notification (toast, banner)


      } catch (err) { // Catch any unexpected errors not from Supabase responses (e.g. network issues)
          console.error("Unexpected error during save process:", err);
          setError('Une erreur inattendue s\'est produite lors de l\'enregistrement.');
      } finally {
          setIsSaving(false); // Always reset saving state
           // If the error state was set, isEditing remains true, otherwise it becomes false
      }
  };

  // Utility to generate initials (remains the same)
  const getInitials = (nameStr) => {
    if (!nameStr || typeof nameStr !== 'string') return 'N/A';
    const parts = nameStr.trim().split(' ').filter(part => part.length > 0);
    if (parts.length === 0) return 'N/A';
    if (parts.length === 1) return parts[0].substring(0, Math.min(parts[0].length, 2)).toUpperCase();
    return (parts[0][0] + (parts.length > 1 && parts[parts.length - 1].length > 0 ? parts[parts.length - 1][0] : '')).toUpperCase();
  };

  // Determine which data object to display - formData when editing, user when viewing
  // Fallback to a placeholder if user/formData haven't loaded yet
  const displayedUser = formData || user; // Use formData if available (means either loading or editing)

  // --- Conditional Rendering ---

  // Show loading indicator while fetching initial data
  if (isLoading) {
      return (
           <div className="profile-page fade-in-up" style={{ textAlign: 'center', padding: '50px' }}>
               <p>Chargement du profil...</p>
                {/* Add a loading spinner here if you have a CSS class for it */}
            </div>
       );
   }

   // Show error message if initial fetch failed and no data is available
   if (error && !user) {
        return (
             <div className="profile-page fade-in-up" style={{ textAlign: 'center', padding: '50px', color: 'var(--expired-status-text)' }}>
                 <p>Erreur lors du chargement du profil : {error}</p>
                  {/* Optionally add a retry button */}
             </div>
        );
    }

    // If data is loaded or we have error but partial data (less likely with .single()), render the form/details
    // If data fetch failed totally (`!user` is true), the above block handles it.
    // If we get here, `user` *should* have been successfully populated from fetchProfile,
    // even if there was a customerProfileError where address is missing.

    // Ensure displayedUser has structure even if optional parts were missing
    // (e.g. if address failed to fetch)
    const safeDisplayedUser = displayedUser || { // Provide default empty object structure if somehow displayedUser is still null
         clientId: 'N/A',
         firstName: '',
         lastName: '',
         email: '',
         phone: '',
         address: '',
         name: '' // This will be recomputed by getInitials
    };


  return (
    <div className="profile-page fade-in-up"> {/* Main container for the page */}
      <div className="page-header"> {/* Centered by global App.css styles */}
        <h1>Profil</h1>
        <p className="text-secondary">Gérez vos informations personnelles.</p>
      </div>

      {/* Display save error at the top of the form section */}
      {error && !isLoading && ( // Show save error only if not currently loading/saving
          <div className="auth-message error" style={{margin: '20px auto', maxWidth: '600px', textAlign: 'center'}}>{error}</div>
      )}


      {/* Container for profile content, allows for consistent horizontal margins */}
      <div className="profile-content-container">
        {/* Profile Summary Card - Now uses .profile-section-card for new styling */}
        <section className="profile-section-card profile-summary-card-styled">
          {/* Use safeDisplayedUser here as well */}
          <div className="profile-avatar-lg">{getInitials(safeDisplayedUser.name || `${safeDisplayedUser.firstName} ${safeDisplayedUser.lastName}`)}</div> {/* Use name, or fall back to firstName/lastName */}
          <div className="profile-summary-details">
             <h2>{safeDisplayedUser.name || `${safeDisplayedUser.firstName} ${safeDisplayedUser.lastName}`.trim() || 'Nom Inconnu'}</h2>
             {/* Only show client ID if loaded */}
            {user?.clientId && <p className="text-secondary">ID Client : {user.clientId}</p>} {/* Client ID is usually not editable */}
             {safeDisplayedUser.email && <p className="text-secondary">{safeDisplayedUser.email}</p>}
             {safeDisplayedUser.phone && <p className="text-secondary">{safeDisplayedUser.phone}</p>}
          </div>
          {!isEditing && user && ( // Only show edit button if NOT editing AND data has been loaded (user is not null)
              <button className="btn btn-secondary btn-icon" onClick={handleEdit} disabled={isLoading}> {/* Uses global .btn-secondary */}
                <FiEdit /> Modifier le Profil
              </button>
          )}
           {/* Optionally show disabled edit button while loading but data available, or saving? */}
            {isSaving && (
                 <button className="btn btn-secondary btn-icon" disabled>
                    <FiEdit /> Enregistrement...
                 </button>
             )}
        </section>

        {/* Personal Information Form Card - Now uses .profile-section-card */}
        {/* Show the form section only if user data has been loaded (user is not null) */}
         {user && (
            <section className="profile-section-card profile-details-card-styled">
                <h3 className="profile-section-title">Informations Personnelles</h3>
                 {/* Prevent default form submit only if editing to allow Enter key to trigger save */}
                <form onSubmit={(e) => { e.preventDefault(); if (isEditing && !isSaving) handleSave(); }}>
                    <div className="form-grid"> {/* Grid for inputs */}
                    {/* Prénom */}
                    <div className="form-group">
                        <label className="label" htmlFor="profileFirstName">Prénom</label>
                        <input
                        type="text"
                        id="profileFirstName"
                        name="firstName"
                        className="input-field"
                        value={formData?.firstName || ''} // Use optional chaining and default to empty string for safety
                        onChange={handleChange}
                        disabled={!isEditing || isSaving} // Disable while not editing or saving
                        required
                        />
                    </div>
                    {/* Nom */}
                    <div className="form-group">
                        <label className="label" htmlFor="profileLastName">Nom</label>
                        <input
                        type="text"
                        id="profileLastName"
                        name="lastName"
                        className="input-field"
                        value={formData?.lastName || ''} // Use optional chaining
                        onChange={handleChange}
                        disabled={!isEditing || isSaving} // Disable while not editing or saving
                        required
                        />
                    </div>
                    {/* Email - Often not editable this way, but matches previous implementation */}
                    {/* Be aware of Supabase requiring email verification on change */}
                    <div className="form-group">
                        <label className="label" htmlFor="profileEmail">Adresse e-mail</label>
                        <input
                        type="email"
                        id="profileEmail"
                        name="email"
                        className="input-field"
                        value={formData?.email || ''} // Use optional chaining
                        onChange={handleChange}
                        disabled={!isEditing || isSaving} // Disable while not editing or saving
                         // email pattern helps basic validation
                        pattern="[a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,}$"
                        required
                        />
                    </div>
                    {/* Phone (Mapping to phone_number in DB) */}
                    <div className="form-group">
                        <label className="label" htmlFor="profilePhone">Téléphone</label>
                        <input
                        type="tel" // Use tel type for phone number keyboard hint
                        id="profilePhone"
                        name="phone" // Use 'phone' in state/form
                        className="input-field"
                        value={formData?.phone || ''} // Use optional chaining
                        onChange={handleChange}
                        disabled={!isEditing || isSaving} // Disable while not editing or saving
                         // pattern can be added for specific phone formats if needed
                        required
                        />
                    </div>
                    {/* Address (Full Width) */}
                    <div className="form-group form-grid-full-width">
                        <label className="label" htmlFor="profileAddress">Adresse</label>
                        <input
                        type="text"
                        id="profileAddress"
                        name="address" // Use 'address' in state/form
                        className="input-field"
                        value={formData?.address || ''} // Use optional chaining
                        onChange={handleChange}
                        disabled={!isEditing || isSaving} // Disable while not editing or saving
                        required
                        />
                    </div>
                    </div>
                    {/* Action Buttons */}
                    <div className="profile-form-actions">
                    {isEditing ? (
                        <>
                            <button type="button" className="btn btn-secondary btn-icon" onClick={handleCancel} disabled={isSaving}> {/* Disable cancel while saving */}
                                <FiXCircle /> Annuler
                            </button>
                             {/* Change type to 'submit' to allow form submission on Enter key */}
                            <button type="submit" className="btn btn-primary btn-icon" disabled={isSaving}> {/* Disable save while saving */}
                                {isSaving ? <><span className="spinner"></span> Enregistrement...</> : <><FiSave /> Enregistrer</>}
                            </button>
                        </>
                    ) : (
                        // When not editing, show a disabled primary button as a visual cue
                        // Clicking "Modifier le Profil" enables the form and changes buttons
                         <button type="button" className="btn btn-primary btn-icon" disabled>
                            <FiSave /> Enregistrer
                         </button>
                    )}
                    </div>
                </form>
            </section>
         )}
      </div>
    </div>
  );
};

export default Profile;
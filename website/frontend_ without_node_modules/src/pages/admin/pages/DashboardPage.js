// frontend/src/pages/admin/pages/DashboardPage.js
import React, { useState, useEffect } from 'react';
import { useNavigate, useLocation } from 'react-router-dom'; // Keep useLocation if you need state from redirect
import { supabase } from '../../../supabaseClient'; // Import supabase client

// Assuming you keep these placeholder images or replace with real chart components
import lineChartPlaceholder from '../assets/placeholder-line-chart.svg'; // <-- Added import
import donutChartPlaceholder from '../assets/placeholder-donut-chart.svg'; // <-- Added import

// CSS Imports
import '../../admin/styles/_base.css';
import '../../admin/styles/DashboardPage.css';

// Define the structure for the dashboard data with default/initial values
// Ensure keys match potential Supabase response structure (snake_case usually)
const defaultDashboardData = {
    total_records: 'N/A',
    last_updated_timestamp: null,
    date_created_timestamp: null, // Placeholder, actual implementation might differ
    // Chart data structures remain arrays, but will be populated from fetched data
    activity_over_time: [],
    data_distribution: [],
};

function DashboardPage() {
    const [adminInfo, setAdminInfo] = useState(null);
    const [dashboardData, setDashboardData] = useState(defaultDashboardData);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState(null);
    const navigate = useNavigate();
    const location = useLocation(); // Needed if checking location.state from redirect

    useEffect(() => {
        let isMounted = true;

        async function fetchDashboardData() {
            setIsLoading(true);
            setError(null);

            try {
                // Get the currently authenticated user session
                const { data: { user }, error: userAuthError } = await supabase.auth.getUser();

                if (!isMounted) return; // Check mount status

                if (userAuthError || !user) {
                    // User not found or error, ProtectedRoute should handle redirect, but log it
                    console.error("User not found for dashboard:", userAuthError);
                    if (isMounted) {
                         setError("Utilisateur non trouvé."); // Set a basic error if not redirected by ProtectedRoute
                         setIsLoading(false);
                    }
                    return; // Exit early if no user
                }

                console.log("Fetching admin dashboard data for user ID:", user.id);

                // 1. Fetch basic admin user info for the greeting
                const { data: userData, error: userFetchError } = await supabase
                    .from('users') // Assuming a public.users table
                    .select('first_name, last_name')
                    .eq('id', user.id)
                    .single();

                if (isMounted) {
                    if (userFetchError) {
                        console.error("Error fetching admin user data:", userFetchError);
                        setError(prev => (prev || '') + ' Erreur lors du chargement des informations utilisateur.');
                        setAdminInfo({ name: user.email }); // Fallback
                    } else {
                        console.log("Fetched admin user data:", userData);
                         setAdminInfo({ name: `${userData?.first_name || ''} ${userData?.last_name || ''}`.trim() || user.email });
                    }
                }


                // 2. Fetch aggregate and summary data

                // Fetch counts for total records
                const { count: usersCount, error: usersCountError } = await supabase
                    .from('users') // Ensure RLS allows count for admins
                    .select('*', { count: 'exact', head: true });

                const { count: productsCount, error: productsCountError } = await supabase
                    .from('customer_product') // Ensure RLS allows count for admins
                    .select('*', { count: 'exact', head: true });

                const { count: ticketsCount, error: ticketsCountError } = await supabase
                    .from('customer_tickets') // Ensure RLS allows count for admins
                    .select('*', { count: 'exact', head: true });

                 const { count: problemsCount, error: problemsCountError } = await supabase
                    .from('problems_solutions') // Ensure RLS allows count for admins
                    .select('*', { count: 'exact', head: true });


                // Calculate total records, handle potential null counts
                 const calculatedTotalRecords = (usersCount || 0) + (productsCount || 0) + (ticketsCount || 0) + (problemsCount || 0);


                // Fetch latest updated timestamp across key tables (example using tickets)
                 const { data: latestTicket, error: latestTicketError } = await supabase
                    .from('customer_tickets')
                    .select('updated_at')
                    .order('updated_at', { ascending: false })
                    .limit(1)
                    .single();

                 // --- Placeholder for complex chart data queries ---
                 // Replace these with actual queries fetching real data
                 // Example: Fetch activity data (e.g., insertions over time) - requires a table/view tracking this
                 const fetchedActivityOverTime = [ /* Fetch data for chart */ ]; // Example placeholder

                 // Example: Fetch data distribution (counts per table or category)
                 const fetchedDataDistribution = [
                      { type: 'Clients', count: usersCount || 0, color: 'var(--accent-color)' },
                      { type: 'Produits Clients', count: productsCount || 0, color: 'var(--secondary-accent-color)' },
                      { type: 'Tickets', count: ticketsCount || 0, color: 'var(--pending-status-generic-bg)' },
                       { type: 'Base de Connaissance', count: problemsCount || 0, color: 'var(--card-bg-lighter)' },
                 ];


                // Check for any errors during data fetches
                 const fetchErrors = [usersCountError, productsCountError, ticketsCountError, problemsCountError, latestTicketError /* add others */].filter(Boolean); // Filter out null/undefined errors
                 if (fetchErrors.length > 0) {
                     console.error("Errors occurred during dashboard data fetch:", fetchErrors);
                      setError(prev => (prev || '') + ' Certaines données statistiques n\'ont pas pu être chargées.');
                 }


                if (isMounted) {
                    setDashboardData({
                        total_records: calculatedTotalRecords !== null ? calculatedTotalRecords.toLocaleString() : 'N/A',
                        last_updated_timestamp: latestTicket?.updated_at || null,
                        date_created_timestamp: null, // Still using placeholder - replace with actual fetch
                        activity_over_time: fetchedActivityOverTime,
                        data_distribution: fetchedDataDistribution,
                    });
                    setIsLoading(false);
                }

            } catch (err) {
                if (!isMounted) return;
                console.error("Unexpected error during admin dashboard data fetch:", err);
                setError('Une erreur inattendue est survenue lors du chargement du tableau de bord.');
                 setDashboardData(defaultDashboardData); // Fallback
                setIsLoading(false);
            }
        }

        fetchDashboardData();

        return () => { isMounted = false; };

    }, [supabase, navigate, location]); // Added location to deps

    const formatTimestamp = (isoString) => {
        if (!isoString) return 'N/A';
        try {
            const date = new Date(isoString);
             if (isNaN(date.getTime())) return 'Date invalide';
            return date.toLocaleDateString('fr-FR', { year: 'numeric', month: 'long', day: 'numeric' });
        } catch (e) {
             console.error("Error formatting date:", e);
            return 'Date invalide';
        }
    };

    // Calculate total for donut legend locally
    const totalEquipment = (dashboardData.data_distribution?.length > 0) ?
         dashboardData.data_distribution.reduce((sum, item) => sum + item.count, 0) : 0;
     const showDonutChartLegend = dashboardData.data_distribution && dashboardData.data_distribution.length > 0 && totalEquipment > 0;


    return (
        <div className="dashboard-page fade-in-up">
             <div className="dashboard-header">
                <h1>Bienvenue <span className="admin-highlight">{adminInfo?.name || 'Admin'}</span>!</h1>
                <p>Gérer les éléments facilement</p>
                 {error && <div className="error-message" style={{margin: '20px'}}>{error}</div>}
            </div>

            {isLoading ? (
                 <div className="loading-state" style={{textAlign: 'center', padding: '50px'}}>
                      <h2>Chargement des données...</h2>
                 </div>
            ) : (
            <div className="dashboard-main-content">
                {/* Charts Section */}
                 {/* You would replace img tags with your charting library components here,
                     passing dashboardData.activity_over_time and dashboardData.data_distribution */}
                <div className="dashboard-charts">
                    <div className="chart-container line-chart-container">
                         {/* Conditional rendering based on data availability for chart */}
                         {dashboardData.activity_over_time && dashboardData.activity_over_time.length > 0 ? (
                             // Implement your actual charting library component here, passing dashboardData.activity_over_time
                             <img src={lineChartPlaceholder} alt="Graphique linéaire (Exemple)" className="chart-placeholder-img" /> // Using placeholder for demo
                         ) : (
                             <p className="text-secondary" style={{textAlign: 'center', padding: '20px'}}>Aucune donnée d'activité disponible pour le graphique linéaire.</p>
                         )}
                    </div>
                    <div className="chart-container donut-chart-container">
                         {/* Conditional rendering based on data availability and if there are items to display */}
                         {showDonutChartLegend ? (
                             <>
                             {/* Implement your actual charting library component here, passing dashboardData.data_distribution */}
                             <img src={donutChartPlaceholder} alt="Graphique Donut (Exemple)" className="chart-placeholder-img" /> // Using placeholder for demo
                              {/* Dynamic Legend */}
                             <div className="donut-chart-legend">
                                {dashboardData.data_distribution.map((item, index) => (
                                    <div key={item.type || index}>
                                        <span className="legend-color-box" style={{ backgroundColor: item.color }}></span>
                                        {item.type || 'Type Inconnu'} <span className="legend-value">{item.count}</span>
                                    </div>
                                ))}
                             </div>
                             </>
                         ) : (
                            <p className="text-secondary" style={{textAlign: 'center', padding: '20px'}}>Aucune donnée de répartition disponible.</p>
                         )}
                    </div>
                </div>

                {/* Stats Section - Display fetched data */}
                <div className="dashboard-stats">
                    <div className="stat-card">
                        <h3>Total Enregistrements</h3>
                        {/* Display fetched total records or N/A */}
                        <p>{dashboardData.total_records}</p>
                    </div>
                    <div className="stat-card">
                        <h3>Dernière Mise à Jour</h3>
                         {/* Format and display fetched last updated timestamp or N/A */}
                        <p>{formatTimestamp(dashboardData.last_updated_timestamp)}</p>
                    </div>
                    <div className="stat-card">
                        <h3>Date de Création</h3>
                        {/* This still uses a placeholder date format as fetching project creation date is complex */}
                        <p>Date non disponible</p> {/* Or use a static date if appropriate */}
                    </div>
                </div>
            </div>
            )} {/* End Conditional Render */}

            {/* You can add more sections here as needed, dynamically fetching or using fetched data */}

        </div>
    );
}

export default DashboardPage;
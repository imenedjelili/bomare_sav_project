// frontend/src/pages/admin/pages/DatabaseManagementPage.js
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { supabase } from '../../../supabaseClient'; // Import supabase
import FileIcon from '../components/FileIcon';

// CSS Imports
import '../../admin/styles/_base.css';
import '../../admin/styles/DatabaseManagementPage.css';

const DatabaseManagementPage = () => {
  const [records, setRecords] = useState([]);
  const [searchTerm, setSearchTerm] = useState('');
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);
  const navigate = useNavigate();

  useEffect(() => {
    setIsLoading(true);
    setError(null);
    async function fetchRecords() {
      try {
        // Fetch all records from the problems_solutions table
        // RLS policy "Everyone can view problems_solutions" (or Admin policy) must be active
        const { data, error } = await supabase
          .from('problems_solutions')
          .select('*'); // Select all columns

        if (error) {
          console.error("Error fetching records:", error);
          setError("Erreur lors du chargement des enregistrements.");
          setRecords([]); // Clear existing records on error
        } else {
          console.log("Fetched records:", data);
          setRecords(data || []); // Set records, default to empty array if data is null/undefined
        }
      } catch (err) {
         console.error("Unexpected error fetching records:", err);
         setError("Une erreur inattendue est survenue.");
         setRecords([]);
      } finally {
        setIsLoading(false);
      }
    }

    fetchRecords();
  }, [supabase]); // Dependency on supabase client

  const handleEdit = (recordId) => {
    // Find the record data to pass (optional but efficient)
    const recordData = records.find(r => r.id === recordId);
     if (recordData) {
         // Navigate to the update page, passing the record data via state
         // This avoids re-fetching data on the update page if already available
         navigate(`/admin/update-general-database/${recordId}`, { state: { recordData } });
     } else {
          console.warn("Record not found in state for editing:", recordId);
          // Fallback: Navigate without state, the update page will fetch by ID
          navigate(`/admin/update-general-database/${recordId}`);
     }
  };

  const handleAdd = () => {
     navigate('/admin/add-data'); // Navigate to the add new record page
  };

  const handleDelete = async (recordId) => {
    if (window.confirm('Are you sure you want to delete this record?')) {
      setIsLoading(true); // Show loading while deleting
      setError(null);
      try {
        // Find the record to get file names before deleting the record itself
        const recordToDelete = records.find(r => r.id === recordId);

        // Delete the record from the database
        // RLS policy "Admins have full access on problems_solutions" must be active
        const { error: deleteError } = await supabase
          .from('problems_solutions')
          .delete()
          .eq('id', recordId);

        if (deleteError) {
          console.error("Error deleting record:", deleteError);
          setError("Erreur lors de la suppression de l'enregistrement.");
        } else {
          console.log("Record deleted:", recordId);

          // --- Optional: Delete associated files from Storage ---
          // This is complex and requires knowing the storage paths/names
          // Assuming file names in the DB columns correspond to paths in 'admin-files' bucket
          const fileDeletes = [];
          const fileNames = [
              ...(recordToDelete?.photos || []),
              ...(recordToDelete?.documents || []),
              ...(recordToDelete?.videos || []),
          ].filter(name => name); // Filter out null/empty names

          if (fileNames.length > 0) {
               // In a real app, you might store relative paths like 'problems_solutions/photos/file.jpg'
               // For this example, let's assume the names in the DB are the actual object paths in the bucket.
               // ADJUST PATHS AS NECESSARY for your actual Storage structure.
               const pathsToDelete = fileNames; // Assuming names are the full paths within the bucket

              console.log("Attempting to delete associated files:", pathsToDelete);

              try {
                  // RLS policy "Admins can manage files in admin_files" must be active
                  const { data: deletedFiles, error: storageError } = await supabase.storage
                      .from('admin_files') // Your bucket name
                      .remove(pathsToDelete); // Pass array of paths to remove

                   if (storageError) {
                       console.error("Error deleting files from Storage:", storageError);
                       // Don't block the UI, but inform admin
                       setError(prev => (prev || '') + ` Erreur lors de la suppression des fichiers associ√©s: ${storageError.message}`);
                   } else {
                       console.log("Files deleted from Storage:", deletedFiles);
                   }
              } catch (storageCatchError) {
                   console.error("Unexpected error during file deletion:", storageCatchError);
                   setError(prev => (prev || '') + ` Erreur inattendue lors de la suppression des fichiers: ${storageCatchError.message}`);
              }
          }
          // --- End Optional File Deletion ---


          // Update the local state to remove the deleted record
          setRecords(prevRecords => prevRecords.filter(record => record.id !== recordId));
        }
      } catch (err) {
         console.error("Unexpected error during deletion:", err);
         setError("Une erreur inattendue est survenue lors de la suppression.");
      } finally {
        setIsLoading(false); // Hide loading
      }
    }
  };

  // Format file names for display (showing count if multiple)
  const formatFileNames = (filesArray) => {
    if (!filesArray || filesArray.length === 0) {
      return null; // Indicate no files
    }
    if (filesArray.length === 1) {
      // Extract name from path if needed, e.g., filesArray[0].split('/').pop()
       const fileName = filesArray[0]; // Assuming name is stored directly
      return fileName.length > 15 ? `${fileName.substring(0, 12)}...` : fileName; // Truncate long names
    }
    return `${filesArray.length} files`; // Show count for multiple files
  };


   // Determine FileIcon type based on the first file name (basic guess)
   const getFileIconType = (filesArray) => {
       if (!filesArray || filesArray.length === 0) return null;
       const fileName = filesArray[0]?.toLowerCase();
        if (!fileName) return null;

       if (fileName.endsWith('.jpg') || fileName.endsWith('.jpeg') || fileName.endsWith('.png') || fileName.endsWith('.gif')) return 'photo';
       if (fileName.endsWith('.pdf')) return 'document';
       if (fileName.endsWith('.mp4') || fileName.endsWith('.mov') || fileName.endsWith('.avi')) return 'video';
        // Add other types as needed
       return 'document'; // Default icon if type is unknown
   };


  // Filtered records based on search term
  const filteredRecords = records.filter(record =>
    (record.problem && record.problem.toLowerCase().includes(searchTerm.toLowerCase())) ||
    (record.solution && record.solution.toLowerCase().includes(searchTerm.toLowerCase()))
     // Note: Searching within file names is harder without fetching file metadata or if only paths are stored
  );

  const columnDataLabels = ["Problem", "Solution", "Photos", "Docs", "Videos", "Actions"];


  return (
    <div className="db-management-page admin-main-content-wrapper">
      <div className="page-sub-header logs-header">
        <h2>Manage Your Database Easily</h2>
        <div className="search-container db-controls">
            <input
              type="search" placeholder="Search records (problem or solution)"
              className="search-input form-control"
              value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)}
            />
            <button className="search-icon-btn" type="button"><span className="search-icon-actual">üîç</span></button>
        </div>
      </div>

      {error && <div className="error-message" style={{margin: '20px'}}>{error}</div>}

      {isLoading ? (
          <div className="loading-state" style={{textAlign: 'center', padding: '50px'}}>
               <h2>Chargement des enregistrements...</h2>
          </div>
      ) : (
      <div className="db-table-container records-list-container">
        <div className="db-table-header record-grid">
          {columnDataLabels.map(label => <div key={label} className="record-cell db-col">{label}</div>)}
        </div>
        <div className="db-table-body">
          {filteredRecords.length > 0 ? (
            filteredRecords.map(record => (
              <div key={record.id} className="db-table-row record-grid">
                <div className="record-cell db-col problem-col" data-label="Problem">{record.problem}</div>
                <div className="record-cell db-col solution-col" data-label="Solution">{record.solution}</div>
                 {/* Use helper to display file names or count, and determine icon type */}
                <div className="record-cell db-col files-col" data-label="Photos">
                   {formatFileNames(record.photos)}
                   {record.photos?.length > 0 && <FileIcon type={getFileIconType(record.photos)} />}
                </div>
                <div className="record-cell db-col files-col" data-label="Docs">
                   {formatFileNames(record.documents)}
                   {record.documents?.length > 0 && <FileIcon type={getFileIconType(record.documents)} />}
                </div>
                <div className="record-cell db-col files-col" data-label="Videos">
                   {formatFileNames(record.videos)}
                   {record.videos?.length > 0 && <FileIcon type={getFileIconType(record.videos)} />}
                </div>
                <div className="record-cell db-col actions-col" data-label="Actions">
                  <button onClick={() => handleEdit(record.id)} className="btn btn-edit">Edit</button>
                  <button onClick={() => handleDelete(record.id)} className="btn btn-delete">Delete</button>
                </div>
              </div>
            ))
          ) : (
            <div className="no-records-found">
                {searchTerm ? `No records found matching "${searchTerm}".` : "No records available."}
            </div>
          )}
        </div>
      </div>
       )} {/* End Conditional Render */}

       {/* Add Button - Always visible */}
        <div className="form-actions db-footer-actions">
             <button className="btn btn-confirm db-add-button" onClick={handleAdd}>
                <svg width="18" height="18" viewBox="0 0 24 24"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
                Add New Record
            </button>
        </div>

    </div>
  );
};
export default DatabaseManagementPage;
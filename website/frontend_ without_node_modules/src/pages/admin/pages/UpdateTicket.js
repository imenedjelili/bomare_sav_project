// frontend/src/pages/admin/pages/UpdateTicket.js
import React, { useState, useEffect } from 'react';
import { useNavigate, useParams, useLocation } from 'react-router-dom';
import { supabase } from '../../../supabaseClient'; // Import supabase

// CSS Imports
import '../../admin/styles/_base.css';
import '../../admin/styles/UpdateTicket.css';

function UpdateTicket() {
    const location = useLocation();
    const queryParams = new URLSearchParams(location.search);
    const customerIdFilter = queryParams.get('customerId'); // Get customerId from query params

    // Note: The original component seemed to try and handle a specific ticket view by ID
    // and a list view filtered by customerId.
    // Given the URL structure `/ticket-management/:ticketId` and `/ticket-management?customerId=:customerId`,
    // the `:ticketId` route would match first if present.
    // If we want this component to *only* be a list view (potentially filtered), we should remove the `useParams()` logic.
    // Let's make this primarily a list view, supporting customerId filtering.

    const [problems, setProblems] = useState([]); // Renamed from allProblems for clarity in this component
    const [searchQuery, setSearchQuery] = useState(''); // <-- ADDED useState
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState(null);
    const navigate = useNavigate();

    // Status options matching the DB ENUM
    const ticketStatusOptions = [
        { value: 'open', label: 'Ouvert' },
        { value: 'pending', label: 'En attente' },
        { value: 'solved', label: 'Résolu' },
    ];

    // <-- MOVED fetchTickets OUTSIDE useEffect
    const fetchTickets = async (customerId, setLoading, setError, setProblems) => {
         setLoading(true);
         setError(null);
         try {
             let query = supabase
                 .from('customer_tickets')
                 .select(`
                     id,
                     description,
                     date,
                     last_update, -- Use snake_case for DB column
                     status,
                     customer_id,
                     customers (first_name, last_name) -- Join to fetch customer name
                 `);

             // If customerId is in the URL, filter by it
             if (customerId) {
                 console.log("Filtering tickets for customer ID:", customerId);
                 query = query.eq('customer_id', customerId);
             } else {
                  console.log("Fetching all tickets (no customer filter).");
             }

              // Order by creation date descending by default
             query = query.order('created_at', { ascending: false });

             // RLS policy "Admins have full access on customer_tickets" (or technician) must be active
             const { data, error } = await query;

             if (error) {
                 console.error("Error fetching tickets:", error);
                 setError("Erreur lors du chargement des tickets.");
                 setProblems([]);
             } else {
                 console.log("Fetched tickets:", data);
                 // Augment data to include a combined 'client' name
                 const augmentedData = data.map(ticket => ({
                     ...ticket,
                      // Combine fetched customer names, fallback if join fails or names are null
                     client_name: `${ticket.customers?.first_name || ''} ${ticket.customers?.last_name || ''}`.trim() || `ID:${ticket.customer_id}`,
                 }));
                 setProblems(augmentedData || []);
             }
         } catch (err) {
              console.error("Unexpected error fetching tickets:", err);
              setError("Une erreur inattendue est survenue.");
              setProblems([]);
         } finally {
             setLoading(false); // Set loading to false in finally
         }
    };


    useEffect(() => {
        let isMounted = true; // Use cleanup flag if needed, but fetchTickets handles state setters directly now

        fetchTickets(customerIdFilter, setIsLoading, setError, setProblems); // <-- Calling standalone function

        return () => { /* No specific cleanup needed for this fetch */ };

    }, [supabase, customerIdFilter]); // Dependency on customerIdFilter


    const handleStatusChange = async (problemId, newStatus) => {
        setIsLoading(true); // Show loading while updating status
        setError(null);
        try {
            // Update the status and last_update timestamp in the database
            // RLS policy "Admins have full access on customer_tickets" (or technician) must be active
            const { error: updateError } = await supabase
                .from('customer_tickets')
                .update({ status: newStatus, last_update: new Date().toISOString() }) // Use snake_case
                .eq('id', problemId);

            if (updateError) {
                console.error(`Error updating ticket status for ${problemId}:`, updateError);
                setError(`Erreur lors de la mise à jour du statut: ${updateError.message}`);
                 // Re-fetch all to ensure state is correct after potential error
                await fetchTickets(customerIdFilter, setIsLoading, setError, setProblems); // <-- Calling standalone function
            } else {
                 console.log(`Ticket status updated for ${problemId}: ${newStatus}`);
                 // Optimistically update the local state (still good)
                 setProblems(prev =>
                     prev.map(p =>
                         p.id === problemId ? { ...p, status: newStatus, last_update: new Date().toISOString() } : p // Update status and last_update
                     )
                 );
                 setIsLoading(false); // Only set loading false here if optimistic update is successful
            }
        } catch (err) {
             console.error(`Unexpected error updating ticket status ${problemId}:`, err);
             setError(`Une erreur inattendue est survenue lors de la mise à jour du statut.`);
             // Call the standalone fetchTickets function on unexpected error
             await fetchTickets(customerIdFilter, setIsLoading, setError, setProblems); // <-- Calling standalone function
        }
         // Removed redundant finally { setIsLoading(false); }
    };

    // Filtered problems based on search term across multiple fields
    const filteredProblems = problems.filter(problem =>
        (problem.id && String(problem.id).toLowerCase().includes(searchQuery.toLowerCase())) || // Use snake_case
        (problem.description && problem.description.toLowerCase().includes(searchQuery.toLowerCase())) || // Use snake_case
        (problem.client_name && problem.client_name.toLowerCase().includes(searchQuery.toLowerCase())) || // Use client_name from augmented data
        (problem.status && problem.status.toLowerCase().includes(searchQuery.toLowerCase()))
         // Note: Dates are harder to search as strings, might need specific date filtering logic
    );

    const columnLabels = ['ID', 'Description', 'Client', 'Date', 'Last Update', 'Status', 'Update Status']; // Include update status column


    // Function to format date/time
     const formatDateTime = (isoString) => {
         if (!isoString) return 'N/A';
         try {
             const date = new Date(isoString);
             if (isNaN(date.getTime())) return 'Date invalide';
             return date.toLocaleString('fr-FR', { year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
         } catch (e) {
             console.error("Error formatting date:", e);
             return 'Date invalide';
         }
     };
      // Function to format just the date
     const formatDate = (dateString) => {
        if (!dateString) return 'N/A';
        try {
            const date = new Date(dateString); // Assuming dateString is in a format Date constructor understands
            if (isNaN(date.getTime())) return 'Date invalide';
            return date.toLocaleDateString('fr-FR', { year: 'numeric', month: 'long', day: 'numeric' });
        } catch (e) {
             console.error("Error formatting date:", e);
            return 'Date invalide';
        }
     };

     const getStatusLabel = (statusKey) => {
         const map = { open: "Ouvert", pending: "En attente", solved: "Résolu" };
         return map[statusKey] || statusKey?.charAt(0).toUpperCase() + statusKey?.slice(1); // Handle null/undefined statusKey safely
     };


    return (
        <div className="update-ticket-main-content admin-main-content-wrapper">
            <div className="page-header-container header HHeader">
                <h1>Client Dataset Operations</h1>
                <div className="page-header-logo logo">
                </div>
            </div>
            <div className="page-sub-header update-ticket-header">
                <h2 className="update-ticket-title">
                     {customerIdFilter ? `Tickets for Customer ID: ${customerIdFilter}` : "Manage Clients' Problems"}
                </h2>
               {/* Search is always shown in list view */}
                <div className="search-container update-ticket-search-container">
                    <input
                        type="search" placeholder="Search problems..."
                        className="search-input update-ticket-search-input"
                        value={searchQuery} onChange={(e) => setSearchQuery(e.target.value)} // <-- Correct variable
                    />
                    <button className="search-icon-btn update-ticket-search-icon" type="button">
                        <svg viewBox="0 0 24 24"><circle cx="11" cy="11" r="8"></circle><path d="m21 21-4.3-4.3"></path></svg>
                    </button>
                </div>
            </div>

             {error && <div className="error-message" style={{margin: '20px'}}>{error}</div>}

            {isLoading ? (
                 <div className="loading-state" style={{textAlign: 'center', padding: '50px'}}>
                      <h2>Chargement des tickets...</h2>
                 </div>
            ) : (
            <div className="records-list-container update-ticket-records-container">
                 {/* Header Row */}
                {filteredProblems.length > 0 && (
                     <div className="record-list-header record-grid update-ticket-record-content">
                        {columnLabels.map(label => <div key={label} className="record-cell">{label}</div>)}
                    </div>
                )}

                 {/* Data Rows */}
                {filteredProblems.length > 0 ? (
                    filteredProblems.map((problem) => (
                        <div key={problem.id} className="record-card-item update-ticket-record">
                             {/* Use snake_case keys from DB + client_name from augmentation */}
                            <div className="record-grid update-ticket-record-content">
                                <div className="record-cell update-ticket-id-cell" data-label="ID"><p>{problem.id}</p></div>
                                <div className="record-cell update-ticket-description-cell" data-label="Description"><p>{problem.description}</p></div>
                                <div className="record-cell" data-label="Client"><p>{problem.client_name}</p></div> {/* Use augmented name */}
                                <div className="record-cell update-ticket-date-cell" data-label="Date"><p>{formatDate(problem.date)}</p></div> {/* Format date */}
                                <div className="record-cell update-ticket-update-cell" data-label="Last Update"><p>{formatDateTime(problem.last_update)}</p></div> {/* Format date/time */}
                                <div className="record-cell update-ticket-status-cell" data-label="Status">
                                     {/* Display current status using badge */}
                                    <span className={`status-badge ${problem.status}`}>
                                        {getStatusLabel(problem.status)}
                                    </span>
                                </div>
                                 {/* Status Update Dropdown - Only shown in this list view component */}
                                <div className="record-cell update-ticket-record-actions" data-label="Update Status">
                                    <div className="update-ticket-status-dropdown">
                                        <select
                                            className="form-control update-ticket-status-select"
                                            value={problem.status || 'open'} // Default value if null
                                            onChange={(e) => handleStatusChange(problem.id, e.target.value)}
                                            aria-label={`Update status for ticket ${problem.id}`}
                                            disabled={isLoading} // Disable select during saves
                                        >
                                            {ticketStatusOptions.map(opt => (
                                                <option key={opt.value} value={opt.value}>{opt.label}</option>
                                            ))}
                                        </select>
                                    </div>
                                </div>
                            </div>
                        </div>
                    ))
                ) : (
                     <div className="no-records-found"><p>No tickets found matching your criteria.</p></div>
                )}
            </div>
            )} {/* End Conditional Render */}

             {/* Add New Ticket Button (Optional, if admins can add tickets directly) */}
             {/* <div className="form-actions update-ticket-footer-actions">
                <button className="btn btn-confirm update-ticket-add-button" onClick={() => alert('Add New Ticket (Not Implemented)')} disabled={isLoading}>
                    <svg width="18" height="18" viewBox="0 0 24 24"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
                    Add New Ticket
                </button>
            </div> */}

        </div>
    );
}
export default UpdateTicket;
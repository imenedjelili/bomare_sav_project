// frontend/src/pages/admin/pages/EditDataPage.js
import React, { useState, useEffect } from 'react';
import { useNavigate, useParams, useLocation } from 'react-router-dom';
import { supabase } from '../../../supabaseClient'; // Import supabase
import FileIcon from '../components/FileIcon';

// CSS Imports
import '../../admin/styles/_base.css';
import '../../admin/styles/EditDataPage.css'; // Or AddDataPage.css if styles are identical

// Helper function to upload a single file (reused from AddDataPage)
const uploadFile = async (bucketName, file, filePath) => {
    if (!file) return null;
    try {
        const { data, error } = await supabase.storage
            .from(bucketName)
            .upload(filePath, file);

        if (error) {
            console.error(`Error uploading file ${file.name}:`, error);
            // Depending on criticality, you might return null or the error object
            throw error; // Re-throw the error to be caught by the handleSubmit try/catch
        }
        console.log(`File uploaded successfully: ${data.path}`);
        return data.path; // Return the path where the file was stored in Storage
    } catch (err) {
         console.error(`Failed to upload file ${file.name}:`, err);
         throw err; // Ensure error is propagated
    }
};

// Helper function to delete files from Storage
const deleteFiles = async (bucketName, filePaths) => {
    if (!filePaths || filePaths.length === 0) return;
    try {
        // Supabase Storage remove expects an array of file paths relative to the bucket
        const { data, error } = await supabase.storage
            .from(bucketName) // Your bucket name
            .remove(filePaths); // Pass array of paths to remove

        if (error) {
            console.error(`Error deleting files from ${bucketName}:`, error);
             // Don't re-throw, deletion failures might be less critical than DB update
             // Depending on your app's logic, you might want to log this or alert the user.
        } else {
            console.log(`Files deleted from ${bucketName}:`, data); // Supabase returns { data: [{ key: '...' }], error: null } on success
        }
    } catch (err) {
         console.error(`Unexpected error during file deletion from ${bucketName}:`, err);
    }
};

// Helper to format file names for display (showing count if multiple)
const formatFileNames = (pathsArray) => {
    if (!pathsArray || pathsArray.length === 0) return null;
    if (pathsArray.length === 1) {
        // Assuming path is like 'basePath/category/filename.ext'
        const fileName = pathsArray[0].split('/').pop(); // Get filename from path
        return fileName.length > 15 ? `${fileName.substring(0, 12)}...` : fileName; // Truncate long names
    }
    return `${pathsArray.length} files`; // Show count for multiple files
};

// Helper to determine FileIcon type based on a single file path (basic guess)
const getFileIconTypeFromPath = (filePath) => {
    if (!filePath) return null;
    const fileName = filePath.toLowerCase(); // Use path as filename surrogate for check
    if (fileName.endsWith('.jpg') || fileName.endsWith('.jpeg') || fileName.endsWith('.png') || fileName.endsWith('.gif')) return 'photo';
    if (fileName.endsWith('.pdf')) return 'document';
    if (fileName.endsWith('.mp4') || fileName.endsWith('.mov') || fileName.endsWith('.avi')) return 'video';
    return 'document'; // Default icon if type is unknown
};

// Helper to determine FileIcon type for NEW files based on the first file's type
const getFileIconTypeFromNewFiles = (filesArray) => {
    if (!filesArray || filesArray.length === 0) return null;
    const fileType = filesArray[0]?.type?.toLowerCase();
    if (!fileType) return null;
    if (fileType.startsWith('image/')) return 'photo';
    if (fileType === 'application/pdf') return 'document';
    if (fileType.startsWith('video/')) return 'video';
    return 'document'; // Default
};


const EditDataPage = () => {
  const { recordId } = useParams(); // Get record ID from URL
  const navigate = useNavigate();
  const location = useLocation();

  // Attempt to use state data if passed, otherwise recordId will trigger fetch
  const passedRecordData = location.state?.recordData;

  const [problem, setProblem] = useState('');
  const [solution, setSolution] = useState('');
  const [newPhotosFiles, setNewPhotosFiles] = useState([]);
  const [newDocumentsFiles, setNewDocumentsFiles] = useState([]);
  const [newVideosFiles, setNewVideosFiles] = useState([]);

  // State to track existing files for display and potential deletion
  const [existingPhotoPaths, setExistingPhotoPaths] = useState([]);
  const [existingDocumentPaths, setExistingDocumentPaths] = useState([]);
  const [existingVideoPaths, setExistingVideoPaths] = useState([]);

  const [isSaving, setIsSaving] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);


  useEffect(() => {
    let isMounted = true;

    async function fetchRecordForEdit(id) {
        setIsLoading(true);
        setError(null);
        try {
            // Fetch the specific record from the problems_solutions table by ID
            // RLS policy "Admins have full access on problems_solutions" must be active
            const { data, error } = await supabase
                .from('problems_solutions')
                .select('*') // Select all columns
                .eq('id', id)
                .single(); // Expect a single result

            if (!isMounted) return;

            if (error || !data) {
                console.error(`Error fetching record ${id}:`, error);
                setError(`Enregistrement ${id} introuvable ou erreur lors du chargement.`);
                // Redirect if record not found
                navigate('/admin/database-management', { replace: true });
            } else {
                console.log(`Fetched record ${id} for editing:`, data);
                // Populate state with fetched data
                setProblem(data.problem || '');
                setSolution(data.solution || '');
                setExistingPhotoPaths(data.photos || []); // Store existing paths
                setExistingDocumentPaths(data.documents || []);
                setExistingVideoPaths(data.videos || []);
                 // Clear new file selections initially
                setNewPhotosFiles([]);
                setNewDocumentsFiles([]);
                setNewVideosFiles([]);
            }
        } catch (err) {
             if (!isMounted) return;
            console.error(`Unexpected error fetching record ${id}:`, err);
            setError(`Une erreur inattendue est survenue lors du chargement de l'enregistrement ${id}.`);
             navigate('/admin/database-management', { replace: true });
        } finally {
            if (isMounted) setIsLoading(false);
        }
    }

     // Use passed state data if available, otherwise fetch by ID from URL
     if (passedRecordData && passedRecordData.id === recordId) { // Double check ID matches
         console.log("Using passed record data for editing:", passedRecordData);
         setProblem(passedRecordData.problem || '');
         setSolution(passedRecordData.solution || '');
         setExistingPhotoPaths(passedRecordData.photos || []);
         setExistingDocumentPaths(passedRecordData.documents || []);
         setExistingVideoPaths(passedRecordData.videos || []);
         setNewPhotosFiles([]);
         setNewDocumentsFiles([]);
         setNewVideosFiles([]);
         setIsLoading(false); // Data is loaded
     } else if (recordId) {
        // If no state data, fetch using the ID from the URL
        fetchRecordForEdit(recordId);
     } else {
         // No ID in URL or state - this shouldn't happen if routed correctly, but handle defensively
         console.error("No record ID provided for edit page.");
         navigate('/admin/database-management', { replace: true });
         setIsLoading(false);
     }


    return () => { isMounted = false; }; // Cleanup
  }, [recordId, navigate, passedRecordData, supabase]); // Dependencies: re-run effect if these change

  const handleFileChange = (setter) => (event) => {
    if (event.target.files) {
       // Basic validation could go here if not handled by 'accept'
       setter(Array.from(event.target.files)); // Store File objects in state array
    } else {
      setter([]); // Clear files if input is cleared
    }
  };

   const handleRemoveExistingFile = (fileType, pathToRemove) => {
       if (window.confirm(`Remove existing file: ${pathToRemove.split('/').pop()}?`)) {
           if (fileType === 'photos') {
               setExistingPhotoPaths(prev => prev.filter(p => p !== pathToRemove));
           } else if (fileType === 'documents') {
               setExistingDocumentPaths(prev => prev.filter(p => p !== pathToRemove));
           } else if (fileType === 'videos') {
               setExistingVideoPaths(prev => prev.filter(p => p !== pathToRemove));
           }
            // Note: Actual deletion from Storage happens on handleSubmit
       }
   };


  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!problem.trim() || !solution.trim()) {
      setError("Problem and Solution are required."); // Use error state
      return;
    }

    setIsSaving(true);
    setError(null); // Clear previous errors

    try {
        const bucketName = 'admin_files'; // Your bucket name
        // Use record ID as base path to keep files organized per record
        // Important: Ensure recordId is available here
        if (!recordId) {
             throw new Error("Record ID is missing for file uploads.");
        }
        const basePath = `problems_solutions/${recordId}`;

        // --- File Uploads ---
        const uploadedPhotoPaths = [];
        const uploadedDocumentPaths = [];
        const uploadedVideoPaths = [];

        // Upload new files
        for (const file of newPhotosFiles) {
             // Create a path for the new file, potentially avoiding name conflicts
            const filePath = `${basePath}/photos/${Date.now()}_${file.name}`; // Add timestamp to name
            const path = await uploadFile(bucketName, file, filePath);
            if (path) uploadedPhotoPaths.push(path);
             // Error handling inside uploadFile, so we just check if path was returned
        }

         for (const file of newDocumentsFiles) {
            const filePath = `${basePath}/documents/${Date.now()}_${file.name}`;
            const path = await uploadFile(bucketName, file, filePath);
            if (path) uploadedDocumentPaths.push(path);
        }
         for (const file of newVideosFiles) {
            const filePath = `${basePath}/videos/${Date.now()}_${file.name}`;
            const path = await uploadFile(bucketName, file, filePath);
            if (path) uploadedVideoPaths.push(path);
        }


         // --- Determine files to delete ---
         // Need original paths before any user removal action
         const originalRecordData = location.state?.recordData;
         const initialExistingPhotoPaths = originalRecordData?.photos || [];
         const initialExistingDocumentPaths = originalRecordData?.documents || [];
         const initialExistingVideoPaths = originalRecordData?.videos || [];

         const pathsToDelete = [];

         // Files initially present but now removed from the 'existing' state arrays
         initialExistingPhotoPaths.forEach(path => { if (!existingPhotoPaths.includes(path)) pathsToDelete.push(path); });
         initialExistingDocumentPaths.forEach(path => { if (!existingDocumentPaths.includes(path)) pathsToDelete.push(path); });
         initialExistingVideoPaths.forEach(path => { if (!existingVideoPaths.includes(path)) pathsToDelete.push(path); });


         // --- Delete Files ---
         if (pathsToDelete.length > 0) {
             console.log("Deleting files:", pathsToDelete);
             await deleteFiles(bucketName, pathsToDelete); // Handle errors inside deleteFiles
         }


        // --- Update Record in Database ---
        // Combine remaining existing paths with newly uploaded paths
        const updatedPhotoPaths = [...existingPhotoPaths, ...uploadedPhotoPaths];
        const updatedDocumentPaths = [...existingDocumentPaths, ...uploadedDocumentPaths];
        const updatedVideoPaths = [...existingVideoPaths, ...uploadedVideoPaths];


        const updatedRecordData = {
            problem: problem.trim(),
            solution: solution.trim(),
            photos: updatedPhotoPaths.length > 0 ? updatedPhotoPaths : null, // Use updated arrays, null if empty
            documents: updatedDocumentPaths.length > 0 ? updatedDocumentPaths : null,
            videos: updatedVideoPaths.length > 0 ? updatedVideoPaths : null,
            updated_at: new Date().toISOString(), // Manually update timestamp
        };

        // Update the record by its ID
        // RLS policy "Admins have full access on problems_solutions" must be active
        const { data: updatedRecord, error: updateError } = await supabase
            .from('problems_solutions')
            .update(updatedRecordData)
            .eq('id', recordId) // Use recordId from useParams
            .select() // Select the updated row
            .single(); // Expecting the updated row back

        if (updateError) {
            console.error(`Error updating record ${recordId}:`, updateError);
            setError(`Erreur lors de la mise à jour de l'enregistrement: ${updateError.message}`);
             // TODO: Implement rollback for file uploads/deletions if DB update fails. Very complex.
        } else {
            console.log(`Record ${recordId} updated successfully:`, updatedRecord);
            alert("Enregistrement mis à jour avec succès !");
            // Redirect back to the database management page
            navigate('/admin/database-management');
        }

    } catch (err) {
        // This catches errors from uploadFile or unexpected issues
        console.error("Unexpected error during save:", err);
        setError(`Une erreur inattendue est survenue lors de la mise à jour: ${err.message}`);
         // Note: File upload or deletion errors within the try block will also land here.
    } finally {
        setIsSaving(false);
    }
  };

  const handleCancel = () => {
    navigate('/admin/database-management');
  };


   // Helper to display file names or count for EXISTING files
   const formatFileNames = (pathsArray) => { // <-- Define the helper function
    if (!pathsArray || pathsArray.length === 0) return null;
    if (pathsArray.length === 1) {
        // Assuming path is like 'basePath/category/filename.ext'
        const fileName = pathsArray[0].split('/').pop(); // Get filename from path
        return fileName; // Return full name or truncate
    }
    return `${pathsArray.length} files`; // Show count for multiple files
   };


   // Helper to determine FileIcon type based on a single file path (basic guess)
   const getFileIconTypeFromPath = (filePath) => { // <-- Define the helper function
       if (!filePath) return null;
       const fileName = filePath.toLowerCase(); // Use path as filename surrogate for check
       if (fileName.endsWith('.jpg') || fileName.endsWith('.jpeg') || fileName.endsWith('.png') || fileName.endsWith('.gif')) return 'photo';
       if (fileName.endsWith('.pdf')) return 'document';
       if (fileName.endsWith('.mp4') || fileName.endsWith('.mov') || fileName.endsWith('.avi')) return 'video';
       return 'document'; // Default icon if type is unknown
   };


    // Helper to determine FileIcon type for NEW files based on the first file's type
    const getFileIconTypeFromNewFiles = (filesArray) => { // <-- Define the helper function
        if (!filesArray || filesArray.length === 0) return null;
        const fileType = filesArray[0]?.type?.toLowerCase();
        if (!fileType) return null;
        if (fileType.startsWith('image/')) return 'photo';
        if (fileType === 'application/pdf') return 'document';
        if (fileType.startsWith('video/')) return 'video';
        return 'document'; // Default
    };


  if (isLoading) {
    return <div className="edit-data-page"><h2>Chargement de l'enregistrement...</h2></div>;
  }

   // If recordId is provided but no record data was found after loading
   // Check if recordId exists AND if problem/solution are still empty after loading
   if (!isLoading && recordId && !problem && !solution && existingPhotoPaths.length === 0 && existingDocumentPaths.length === 0 && existingVideoPaths.length === 0) {
       return (
            <div className="edit-data-page admin-main-content-wrapper">
                <div className="error-message" style={{margin: '20px'}}>
                    Enregistrement avec l'ID {recordId} introuvable.
                     {error && ` Détails: ${error}`}
                </div>
                 <div className="form-actions" style={{padding: '20px'}}>
                     <button type="button" className="btn btn-cancel edit-data-btn-cancel" onClick={() => navigate('/admin/database-management')}>Retour à la gestion</button>
                 </div>
            </div>
       );
   }

   // If recordId is present, we are in edit mode.
   // If no recordId, this component shouldn't be rendered via this route structure,
   // AddDataPage handles creation. So we expect recordId here.


  return (
    <div className="edit-data-page admin-main-content-wrapper">
       <div className="page-header-container edit-data-header HHeader"> {/* Use HHeader class */}
           <h1>Update Knowledge Base Record</h1>
           <div className="page-header-logo edit-data-logo">
            </div>
       </div>
      <div className="page-sub-header edit-data-sub-header">
        <h2>Editing Record ID: {recordId}</h2> {/* Display the ID from useParams */}
      </div>

       {error && <div className="error-message" style={{margin: '20px'}}>{error}</div>}

      <form onSubmit={handleSubmit} className="data-form-container edit-data-form">
        <div className="form-group edit-data-form-group">
          <label htmlFor="problemDescUpd">Update the problem description:</label>
          <textarea id="problemDescUpd" value={problem} className="form-control edit-data-form-control"
            onChange={(e) => setProblem(e.target.value)} rows="3" required
            disabled={isSaving} />
        </div>
        <div className="form-group edit-data-form-group">
          <label htmlFor="solutionDescUpd">Update the solution description:</label>
          <textarea id="solutionDescUpd" value={solution} className="form-control edit-data-form-control"
            onChange={(e) => setSolution(e.target.value)} rows="3" required
            disabled={isSaving}/>
        </div>

         {/* Section for Existing Files */}
         {(existingPhotoPaths.length > 0 || existingDocumentPaths.length > 0 || existingVideoPaths.length > 0) && (
            <div className="form-group existing-files-group edit-data-form-group">
                <label>Existing Files:</label>
                <div className="existing-files-list">
                    {existingPhotoPaths.map((path) => (
                        <div key={path} className="existing-file-item">
                            <span>Photo: {formatFileNames([path])}</span> {/* Use helper for display */}
                            <button type="button" onClick={() => handleRemoveExistingFile('photos', path)} className="btn-remove-file edit-data-btn-remove-file" disabled={isSaving}>
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="feather feather-x"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                            </button>
                        </div>
                    ))}
                    {existingDocumentPaths.map((path) => (
                         <div key={path} className="existing-file-item">
                             <span>Doc: {formatFileNames([path])}</span> {/* Use helper for display */}
                             <button type="button" onClick={() => handleRemoveExistingFile('documents', path)} className="btn-remove-file edit-data-btn-remove-file" disabled={isSaving}>
                               <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="feather feather-x"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                             </button>
                         </div>
                    ))}
                     {existingVideoPaths.map((path) => (
                         <div key={path} className="existing-file-item">
                             <span>Video: {formatFileNames([path])}</span> {/* Use helper for display */}
                             <button type="button" onClick={() => handleRemoveExistingFile('videos', path)} className="btn-remove-file edit-data-btn-remove-file" disabled={isSaving}>
                                 <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="feather feather-x"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                             </button>
                         </div>
                     ))}
                </div>
            </div>
         )}

        {/* Section for Uploading New Files */}
        <div className="form-group file-upload-group edit-data-file-group">
          <label htmlFor="photos-edit-btn">Upload new photos:</label>
          <div className="file-input-wrapper edit-data-upload-container">
            <button id="photos-edit-btn" type="button" className="btn btn-upload edit-data-btn-upload" onClick={() => document.getElementById('photos-edit-input').click()} disabled={isSaving}>
              Upload photos
            </button>
            <input type="file" id="photos-edit-input" accept="image/*" multiple onChange={handleFileChange(setNewPhotosFiles)} style={{ display: 'none' }} />
             {newPhotosFiles.length > 0 ? (
                 <span className="file-name-display edit-data-file-name-display">{formatFileNames(newPhotosFiles)}</span>
            ) : (
                 <FileIcon type="photo" className="edit-data-media-icon" />
            )}
          </div>
        </div>

        <div className="form-group file-upload-group edit-data-file-group">
          <label htmlFor="documents-edit-btn">Upload new documents (pdf):</label>
          <div className="file-input-wrapper edit-data-upload-container">
            <button id="documents-edit-btn" type="button" className="btn btn-upload edit-data-btn-upload" onClick={() => document.getElementById('documents-edit-input').click()} disabled={isSaving}>
              Upload files
            </button>
            <input type="file" id="documents-edit-input" accept=".pdf" multiple onChange={handleFileChange(setNewDocumentsFiles)} style={{ display: 'none' }} />
             {newDocumentsFiles.length > 0 ? (
                <span className="file-name-display edit-data-file-name-display">{formatFileNames(newDocumentsFiles)}</span>
             ) : (
                <FileIcon type="document" className="edit-data-media-icon" />
             )}
          </div>
        </div>

        <div className="form-group file-upload-group edit-data-file-group">
          <label htmlFor="videos-edit-btn">Upload new videos:</label>
          <div className="file-input-wrapper edit-data-upload-container">
            <button id="videos-edit-btn" type="button" className="btn btn-upload edit-data-btn-upload" onClick={() => document.getElementById('videos-edit-input').click()} disabled={isSaving}>
              Upload videos
            </button>
            <input type="file" id="videos-edit-input" accept="video/*" multiple onChange={handleFileChange(setNewVideosFiles)} style={{ display: 'none' }} />
            {newVideosFiles.length > 0 ? (
                 <span className="file-name-display edit-data-file-name-display">{formatFileNames(newVideosFiles)}</span>
            ) : (
                 <FileIcon type="video" className="edit-data-media-icon" />
            )}
          </div>
        </div>

        <div className="form-actions edit-data-form-buttons">
          <button type="button" className="btn btn-cancel edit-data-btn-cancel" onClick={handleCancel} disabled={isSaving}>Cancel</button>
          <button type="submit" className="btn btn-confirm edit-data-btn-confirm" disabled={isSaving}>
             {isSaving ? 'Updating...' : 'Confirm Update'}
           </button>
        </div>
      </form>
    </div>
  );
};

export default EditDataPage;
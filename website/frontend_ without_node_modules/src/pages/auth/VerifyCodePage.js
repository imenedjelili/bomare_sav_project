// src/pages/auth/VerifyCodePage.js
import React, { useState, useEffect, useRef } from 'react';
import { Link, useNavigate, useLocation, useSearchParams } from 'react-router-dom';
import { FaArrowLeft } from 'react-icons/fa';

import './AuthPages.css';
import companyLogo from '../../assets/images/bomare-logo.png';
import { supabase } from '../../supabaseClient';

// Define the expected length of the verification code (often 6 digits for manual entry)
// Note: Link-based verification uses a long, complex token, not a simple digit code.
// This CODE_LENGTH is relevant only if you implement/support a manual digit code entry flow.
// If your Supabase email templates ONLY send clickable links, you might remove the manual form entirely.
const MANUAL_CODE_LENGTH = 6; // Assuming a 6-digit code for manual entry

const VerifyCodePage = () => {
    const location = useLocation();
    const navigate = useNavigate();
    // Hook to easily access query parameters from the URL (e.g., /verify-code?token=...&type=...&email=...)
    const [searchParams] = useSearchParams();

    // State variables for manual code entry inputs (an array of digits)
    const [manualCode, setManualCode] = useState(Array(MANUAL_CODE_LENGTH).fill(''));
    // State for manual email entry (might be pre-filled from state)
    const [manualEmail, setManualEmail] = useState(location.state?.email || '');

    const [isSubmitting, setIsSubmitting] = useState(false); // For form submission state
    const [isLoadingAutoVerify, setIsLoadingAutoVerify] = useState(false); // For initial link processing
    const [error, setError] = useState('');
    const [successMessage, setSuccessMessage] = useState(''); // For messages like "email sent" or "verification failed"

    // useRef to store references to the individual manual input elements
    const manualInputRefs = useRef([]);

    // Get potential token and type from URL query parameters (part of Supabase Auth links)
    const tokenFromUrl = searchParams.get('token');
    const typeFromUrl = searchParams.get('type');
    // Get email from URL (usually present for recovery/email verification links)
    const emailFromUrl = searchParams.get('email');


    // --- useEffect for handling Automatic Verification from URL ---
    // This effect runs when the component mounts or when URL parameters change.
    useEffect(() => {
        let isMounted = true; // Flag to prevent state updates after unmount

        const handleAutoVerify = async () => {
            // Only attempt auto-verify if token, type, and email are present in the URL
            if (tokenFromUrl && typeFromUrl && emailFromUrl) {
                console.log(`Attempting automatic verification for type: ${typeFromUrl}, email: ${emailFromUrl}`);

                setIsLoadingAutoVerify(true); // Indicate loading for auto-verify
                setError(''); // Clear any previous errors
                setSuccessMessage(''); // Clear any previous messages

                try {
                    // Call Supabase's verifyOtp method with details from the URL
                    const { data, error: verifyError } = await supabase.auth.verifyOtp({
                        email: emailFromUrl,
                        token: tokenFromUrl,
                        type: typeFromUrl, // Use the type from the URL ('recovery' or 'email')
                    });

                    if (!isMounted) return; // Check mount status before updating state

                    if (verifyError) {
                        console.error("Supabase Auto Verify Error:", verifyError);
                        // Handle specific errors or provide a generic message
                        if (verifyError.message.includes('Invalid or expired')) {
                            setError('Échec de la vérification automatique : Le lien est invalide ou a expiré.');
                        } else {
                            setError(`Erreur lors de la vérification automatique : ${verifyError.message || 'Veuillez réessayer.'}`);
                            // Log detailed error for dev
                            console.error("Detailed Supabase verifyOtp error:", verifyError);
                        }

                        // Important: Clear the URL parameters after failed attempt to avoid re-triggering
                        // Use replace: true to avoid adding to history
                        navigate(location.pathname, { replace: true, state: { email: emailFromUrl } });

                    } else if (data.session) {
                        // Auto-verification successful, user is signed in (temporarily for recovery, maybe permanently for email)
                        console.log("Auto Verification successful, user signed in:", data.user?.id, "Redirecting...");

                        // Redirect based on the type of verification
                        if (typeFromUrl === 'recovery') {
                            // For password recovery links, redirect to the set-password page
                            // Pass the email via state for display on the SetPasswordPage
                            navigate('/set-password', { state: { email: emailFromUrl }, replace: true });

                        } else if (typeFromUrl === 'email') {
                            // For email confirmation links, user is now verified.
                            // Redirect them to login or their dashboard. Fetching role is good practice.
                            // Note: If using a trigger to create the 'Users' profile on auth.users insert,
                            // the profile should exist by now or shortly.
                            try {
                                const { data: userData, error: roleError } = await supabase
                                    .from('Users')
                                    .select('role')
                                    .eq('id', data.user.id)
                                    .single();

                                if (!isMounted) return;

                                if (roleError || !userData?.role) {
                                    console.error("Error fetching role after email verification:", roleError);
                                    // Verification succeeded, but couldn't get profile. Send to login with message.
                                    navigate('/login', { replace: true, state: { message: 'E-mail vérifié, mais impossible de charger le profil. Veuillez vous connecter.', email: emailFromUrl } });
                                } else {
                                    const userRole = userData.role;
                                    let redirectPath = '/';
                                    if (userRole === 'customer') redirectPath = '/customer/dashboard';
                                    else if (userRole === 'technician') redirectPath = '/technician/dashboard';
                                    else if (userRole === 'admin') redirectPath = '/admin/dashboard';
                                    else { // Unrecognized role after verification - should not happen with good data
                                        console.warn("Auto verified user has unrecognized role:", userRole, "Redirecting to login.");
                                        redirectPath = '/login';
                                    }
                                    console.log("Email verified as", userRole, ", redirecting to", redirectPath);
                                    navigate(redirectPath, { replace: true }); // Redirect to dashboard or login
                                }
                            } catch (roleFetchErr) {
                                if (!isMounted) return;
                                console.error("Unexpected error fetching role after email verification:", roleFetchErr);
                                navigate('/login', { replace: true, state: { message: 'E-mail vérifié, mais une erreur est survenue. Veuillez vous connecter.', email: emailFromUrl } });
                            }

                        } else {
                            // Handle other unexpected OTP types from URL
                            console.warn("Auto Verification successful for unhandled type:", typeFromUrl, ". Redirecting to login.");
                            navigate('/login', { replace: true, state: { message: 'Vérification réussie. Veuillez vous connecter.', email: emailFromUrl } });
                        }

                    } else {
                        // Verification was successful (no error) but no session returned.
                        // This *might* happen with certain custom Auth configurations.
                        // Treat it as success but user needs to log in.
                        if (!isMounted) return;
                        console.warn("verifyOtp successful but no session returned. Data:", data);
                        setError('Vérification réussie, mais la connexion automatique a échoué. Veuillez vous connecter.');
                        // Clear the URL parameters
                        navigate(location.pathname, { replace: true, state: { email: emailFromUrl } });
                    }

                } catch (err) { // Catch any unexpected JavaScript/Network errors during verifyOtp call
                    if (!isMounted) return;
                    console.error("VerifyCodePage: Unexpected Error during auto-verification:", err);
                    setError(`Une erreur inattendue est survenue lors de la vérification automatique.`);
                    // Clear URL parameters
                    navigate(location.pathname, { replace: true, state: { email: emailFromUrl } });
                } finally {
                    if (isMounted) setIsLoadingAutoVerify(false); // Finish auto-verify loading
                }
            } else if (!emailFromUrl && !tokenFromUrl) {
                // If no email or token in URL, assume manual entry is the intended flow,
                // OR the user landed here without proper context.
                // If email is also missing from state, redirect to login.
                if (!manualEmail) {
                    console.warn("VerifyCodePage: No email context found (URL or state). Redirecting to login.");
                    // Redirect after a slight delay to prevent flickering on mount
                    const redirectTimer = setTimeout(() => {
                        if (isMounted) navigate('/login', { replace: true, state: { message: 'Veuillez recommencer le processus depuis la page de connexion.' } });
                    }, 1500); // Redirect after 1.5 seconds for clarity

                    // Cleanup the timer if component unmounts
                    return () => {
                        isMounted = false;
                        clearTimeout(redirectTimer);
                    };
                } else {
                    // Email is available from state (likely from ForgotPasswordPage)
                    console.log("Email found in state, setting up for manual code entry.");
                    // Optionally focus the first input after DOM renders
                    const focusTimer = setTimeout(() => {
                        if (isMounted && manualInputRefs.current[0]) {
                            manualInputRefs.current[0].focus();
                        }
                    }, 50);
                    return () => {
                        isMounted = false;
                        clearTimeout(focusTimer);
                    };
                }
            }
            // If only email is present from URL, or only token/type, but not all three needed for auto-verify,
            // and email *is* available (either from URL or state), the component will proceed
            // to render the manual input form below this useEffect block. No further action needed here.

            // Cleanup for `isMounted` in this branch
            return () => { isMounted = false; };


            };
    
            handleAutoVerify();
    
            return () => { isMounted = false; }; // Cleanup for `isMounted`
        }, [tokenFromUrl, typeFromUrl, emailFromUrl, navigate, location.pathname, manualEmail]); // Dependencies


    // --- Handlers for Manual Code Input ---
    const handleChange = (e, index) => {
        const { value } = e.target;
        const newCode = [...manualCode];

        // Only accept single digits or empty string (on clear)
        if (/^[0-9]$/.test(value) || value === '') {
            newCode[index] = value;
            setManualCode(newCode);

            // Move focus to the next input if a digit was entered and it's not the last input
            if (value !== '' && index < MANUAL_CODE_LENGTH - 1) {
                manualInputRefs.current[index + 1]?.focus();
            }
            // Backspace handling for focus is in handleKeyDown
        }
    };

    const handleKeyDown = (e, index) => {
        // Prevent default browser actions for keys we handle or block
        // const allowedKeys = ['Backspace', 'ArrowLeft', 'ArrowRight', 'Tab', 'Delete'];
        // const isModifierKey = e.metaKey || e.ctrlKey || e.altKey;

        if (e.key === 'Backspace') {
            if (!manualCode[index] && index > 0) {
                // If current input is empty and not the first, move focus to the previous input
                manualInputRefs.current[index - 1]?.focus();
            } else if (manualCode[index] !== '') {
                // If current input has a digit, let handleChange clear it, but prevent default navigation
                // Or explicitly clear here if you want Backspace to clear *then* move left
                // const newCode = [...manualCode]; newCode[index] = ''; setManualCode(newCode);
            }
            // e.preventDefault(); // Prevent browser back or character deletion in other inputs. Consider context.

        } else if (e.key === 'ArrowRight') {
            if (index < MANUAL_CODE_LENGTH - 1) {
                manualInputRefs.current[index + 1]?.focus();
            }
            e.preventDefault(); // Prevent default cursor movement

        } else if (e.key === 'ArrowLeft') {
            if (index > 0) {
                manualInputRefs.current[index - 1]?.focus();
            }
            e.preventDefault(); // Prevent default cursor movement
        }
        // Handle other keys like Delete, Tab, Paste separately or let browser defaults/handleChange handle them.
        // The 'onPaste' event is handled by handlePaste below.
        // For standard character input (digits), don't prevent default here, let handleChange handle it via 'onChange'.
    };

    const handlePaste = (e, targetIndex) => {
        e.preventDefault(); // Prevent default paste behavior

        const pasteData = e.clipboardData.getData('text').trim();

        // Check if pasted data contains only digits
        if (/^[0-9]+$/.test(pasteData)) {
            const newCode = [...manualCode];
            let currentInputIndex = targetIndex;
            let pasteCharIndex = 0;

            // Fill the code array from the target input index
            while (currentInputIndex < MANUAL_CODE_LENGTH && pasteCharIndex < pasteData.length) {
                newCode[currentInputIndex] = pasteData[pasteCharIndex];
                currentInputIndex++;
                pasteCharIndex++;
            }
            setManualCode(newCode); // Update state using the correct setter

            // Focus the input after the last character pasted into
            const nextFocusIndex = Math.min(targetIndex + pasteData.length, MANUAL_CODE_LENGTH - 1);
            // Use a slight timeout to ensure DOM updates before focusing
            setTimeout(() => {
                manualInputRefs.current[nextFocusIndex]?.focus();
            }, 0);
        }
    };


    // --- Handler for Manual Code Verification Form Submission ---
    const handleSubmit = async (e) => {
        e.preventDefault();

        const verificationCode = manualCode.join(''); // Combine digits
        // Use manualEmail state for submission
        const emailToVerify = manualEmail;

        if (verificationCode.length !== MANUAL_CODE_LENGTH) {
            setError(`Veuillez entrer un code à ${MANUAL_CODE_LENGTH} chiffres.`);
            setSuccessMessage(''); // Clear resend status
            // Clear code fields and refocus
            setManualCode(Array(MANUAL_CODE_LENGTH).fill(''));
            setTimeout(() => { manualInputRefs.current[0]?.focus(); }, 0);
            return;
        }
        if (!emailToVerify) {
            setError('Adresse e-mail manquante.');
            setSuccessMessage('');
            return;
        }


        setIsSubmitting(true);
        setError('');
        setSuccessMessage('');

        try {
            // --- Call Supabase verifyOtp to validate the entered code ---
            // Use type 'recovery' for password reset codes (if this form is used for that)
            // Or 'email' if it's for email verification after signup.
            // Assuming 'recovery' here as per typical code verification context after "Forgot Password"
            // This depends on how your Supabase email templates are configured for code-based recovery.
            // If {{ .Token }} is a 6-digit code, then type should match.
            // Most often, "Forgot Password" emails send a {{ .ConfirmationURL }} which is handled by auto-verify.
            // This manual form is more for "Enter code: XXXXXX" type emails.
            const { data, error: verifyError } = await supabase.auth.verifyOtp({
                email: emailToVerify,
                token: verificationCode, // Manual code acts as the token here
                type: 'recovery', // IMPORTANT: Specify the type. Change to 'email' if for email confirmation.
            });

            if (verifyError) {
                console.error("Supabase Manual Verify OTP Error:", verifyError);
                // Provide user feedback
                if (verifyError.message.includes('Invalid or expired')) {
                    setError('Code de vérification invalide ou expiré.');
                } else if (verifyError.message.includes('must be a recovery attempt')) { // Example error
                    setError('Ce code n\'est pas valide pour la récupération de mot de passe.');
                } else {
                    setError('Échec de la vérification. Veuillez vérifier le code et réessayer.');
                    console.error("Detailed Supabase verifyOtp error:", verifyError);
                }

                // Clear the entered code fields on failure
                setManualCode(Array(MANUAL_CODE_LENGTH).fill(''));
                setTimeout(() => { manualInputRefs.current[0]?.focus(); }, 0);

            } else if (data.session) {
                // Manual verification successful
                // If type was 'recovery', user is signed in with recovery token
                console.log("Manual Code Verification successful, session obtained:", data.user?.id);
                // Redirect to Set Password page
                navigate('/set-password', { state: { email: emailToVerify }, replace: true });

            } else {
                // Verification successful, but no session returned (unexpected for 'recovery')
                // For 'email' type, this might be normal if email verification doesn't auto-login.
                console.warn("Manual verifyOtp successful but no session returned. Type: recovery. Data:", data);
                setError('Vérification réussie, mais impossible de finaliser le processus. Veuillez contacter l\'assistance.');
                setManualCode(Array(MANUAL_CODE_LENGTH).fill(''));
                setTimeout(() => { manualInputRefs.current[0]?.focus(); }, 0);
            }

        } catch (err) { // Catch unexpected errors
            console.error("Verify Code Unexpected Error during submission:", err);
            setError('Une erreur inattendue est survenue lors de la vérification. Veuillez réessayer.');
            setManualCode(Array(MANUAL_CODE_LENGTH).fill(''));
            setTimeout(() => { manualInputRefs.current[0]?.focus(); }, 0);
        } finally {
            setIsSubmitting(false); // Always reset submitting state
        }
    };

    // --- Handler for "Resend Code" button ---
    const handleResendCode = async () => {
        const emailToResend = manualEmail; // Use manualEmail state for resending

        if (!emailToResend) {
            setError('Adresse e-mail manquante pour renvoyer le code.');
            setSuccessMessage(''); // Clear previous status
            return;
        }
        setSuccessMessage('Envoi d\'un nouveau code...'); // Indicate status
        setError(''); // Clear verification errors

        try {
            // --- Call Supabase resend method ---
            // Request a new OTP. The type should match what you expect to verify.
            // e.g., 'recovery' if this page verifies recovery codes.
            // e.g., 'signup' if this page verifies codes sent after initial signup.
            const { error: resendError } = await supabase.auth.resend({
                type: 'recovery', // Or 'signup', 'email_change' etc. depending on context
                email: emailToResend
            });

            if (resendError) {
                console.error("Supabase Resend OTP Error:", resendError);
                setSuccessMessage(`Échec de l'envoi du nouveau code: ${resendError.message}`);
            } else {
                console.log("Resend request successful for email:", emailToResend);
                setSuccessMessage(`Un nouveau code a été envoyé à ${emailToResend}.`);
            }

            // Clear the status message after a few seconds
            setTimeout(() => { setSuccessMessage(''); }, 8000);

        } catch (err) {
            console.error("Resend Code Unexpected Error:", err);
            setSuccessMessage('Une erreur inattendue est survenue lors de l\'envoi. Veuillez réessayer.');
        }
    };


    // --- Conditional Rendering ---

    // If auto-verify is in progress (means token/type/email were in URL)
    if (isLoadingAutoVerify) {
        return (
            <div className="auth-page-container">
                <div className="auth-card-two-panel">
                    <div className="auth-form-panel" style={{ textAlign: 'center' }}>
                        <div className="auth-logo-container">
                            <img src={companyLogo} alt="BOMARE COMPANY" className="auth-logo" />
                        </div>
                        <h1 className="auth-title">Vérification en cours...</h1>
                        <p className="auth-subtitle">Veuillez patienter pendant la vérification de votre lien.</p>
                        <div className="loading-spinner" style={{ marginTop: '20px' }}></div>
                    </div>
                    <div className="auth-image-panel">
                        <img src="/assets/images/verify_code_pic.jpeg" alt="Illustration Vérification Sécurité" className="auth-page-image" />
                    </div>
                </div>
            </div>
        );
    }

    if (!manualEmail && !emailFromUrl && !isLoadingAutoVerify) { // Check isLoadingAutoVerify to prevent premature render
        return (
            <div className="auth-page-container">
                <div className="auth-card-two-panel">
                    <div className="auth-form-panel">
                        <div className="auth-logo-container">
                            <img src={companyLogo} alt="BOMARE COMPANY" className="auth-logo" />
                        </div>
                        <h1 className="auth-title">Accès Refusé</h1>
                        <p className="auth-subtitle">Pour vérifier votre code, veuillez initier le processus approprié (ex: mot de passe oublié, inscription) pour recevoir un code ou un lien.</p>
                        <Link to="/login" className="auth-back-link" style={{ marginTop: '20px' }}>
                            <FaArrowLeft /> Retour à la connexion
                        </Link>
                    </div>
                    <div className="auth-image-panel">
                        <img src="/assets/images/verify_code_pic.jpeg" alt="Illustration Vérification Sécurité" className="auth-page-image" />
                    </div>
                </div>
            </div>
        );
    }


    // --- Main Render for Manual Code Entry Form ---
    return (
        <div className="auth-page-container">
            <div className="auth-card-two-panel">
                <div className="auth-form-panel">
                    <div className="auth-logo-container">
                        <img src={companyLogo} alt="BOMARE COMPANY" className="auth-logo" />
                    </div>

                    <Link to="/login" className="auth-back-link">
                        <FaArrowLeft /> Retour à la connexion
                    </Link>

                    <h1 className="auth-title">Vérifier le Code</h1>
                    <p className="auth-subtitle">
                        {manualEmail ?
                            `Un code de vérification a été envoyé à ${manualEmail}. Veuillez entrer le code à ${MANUAL_CODE_LENGTH} chiffres ci-dessous.` :
                            `Veuillez entrer le code à ${MANUAL_CODE_LENGTH} chiffres que vous avez reçu.`
                        }
                         Si vous avez cliqué sur un lien dans votre e-mail, la vérification devrait être automatique.
                    </p>

                    {error && <div className="auth-message error">{error}</div>}
                    {successMessage && <div className="auth-message success">{successMessage}</div>}


                    <form onSubmit={handleSubmit} className="auth-form verify-code-form">
                        <div className="auth-form-group">
                            <label htmlFor="manual-email" className="auth-label">Adresse E-mail</label>
                            <input type="email" id="manual-email" className="auth-input-field" placeholder="nom@example.com" value={manualEmail} onChange={e => setManualEmail(e.target.value)} required disabled={isSubmitting} />
                        </div>

                        <label className="auth-label" htmlFor="code-input-0">Code de Vérification</label>
                        <div className="auth-code-inputs-container">
                            {manualCode.map((digit, index) => (
                                <input
                                    key={index}
                                    id={`code-input-${index}`}
                                    ref={el => manualInputRefs.current[index] = el}
                                    type="text"
                                    inputMode="numeric"
                                    pattern="[0-9]*"
                                    maxLength="1"
                                    value={digit}
                                    onChange={(e) => handleChange(e, index)}
                                    onKeyDown={(e) => handleKeyDown(e, index)}
                                    onPaste={(e) => handlePaste(e, index)}
                                    className="auth-code-input-box"
                                    required
                                    disabled={isSubmitting}
                                    autoComplete={index === 0 ? 'one-time-code' : 'off'}
                                    aria-label={`Chiffre ${index + 1} du code de vérification`}
                                />
                            ))}
                        </div>

                        <div className="auth-resend-container">
                            <span>Vous n'avez pas reçu de code ?{' '}</span>
                            <button
                                type="button"
                                className="auth-link as-button"
                                onClick={handleResendCode}
                                disabled={isSubmitting || successMessage.includes('Envoi en cours') || !manualEmail}
                            >
                                Renvoyer le code
                            </button>
                        </div>

                        <button
                            type="submit"
                            className="btn btn-primary auth-submit-btn"
                            disabled={isSubmitting || manualCode.join('').length !== MANUAL_CODE_LENGTH || !manualEmail}
                        >
                            {isSubmitting ? 'Vérification...' : 'Vérifier le Code'}
                        </button>
                    </form>


                </div>
                <div className="auth-image-panel">
                    <img src="/assets/images/verify_code_pic.jpeg" alt="Illustration Vérification Sécurité" className="auth-page-image" />
                </div>
            </div>
        </div>
    );
};

export default VerifyCodePage;
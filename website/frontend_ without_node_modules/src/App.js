// src/App.js
import React, { useState, useEffect, Suspense } from 'react';
import { BrowserRouter, Routes, Route, Navigate, Link, useLocation, useNavigate, useSearchParams } from 'react-router-dom';
import { useTranslation } from 'react-i18next';
import { supabase } from './supabaseClient';

// Layouts
import CustomerLayout from './components/Layout';
import TechnicianLayout from './components/technician/TechnicianLayout';

// CORE PUBLIC/AUTH PAGES
import AuthSwitcherPage from './pages/auth/AuthSwitcherPage';
import ForgotPasswordPage from './pages/auth/ForgotPasswordPage';
import SetPasswordPage from './pages/auth/SetPasswordPage';

// PUBLIC HOME/INFO PAGES
import HomePage from './pages/home/HomePage';
import PublicAboutPage from './pages/home/PublicAboutPage';
import PublicReportIssuePage from './pages/home/PublicReportIssuePage';
import ContactSupportPage from './pages/home/ContactSupportPage';
import PrivacyPolicyPage from './pages/home/PrivacyPolicyPage';
import TermsOfUsePage from './pages/home/TermsOfUsePage';

import ChatInterface from './pages/chatbot_tech/pages/ChatInterface'; // Ensure this is correctly imported

// PROTECTED CUSTOMER PAGES
import CustomerDashboard from './pages/customer/Dashboard';
import CustomerProfile from './pages/customer/Profile';
import CustomerKnowledgeBase from './pages/customer/KnowledgeBase';
import CustomerMyProblems from './pages/customer/MyProblems';
import CustomerReportIssue from './pages/customer/ReportIssue';
import MyProductsPage from './pages/customer/MyProductsPage';
import CustomerWarrantyProducts from './pages/customer/WarrantyProducts';
import CustomerNotifications from './pages/customer/Notifications';
import SettingsPage from './pages/customer/SettingsPage';
import AboutPage from './pages/customer/AboutPage';
import FAQPage from './pages/customer/FAQPage';
import RegisterProductPage from './pages/customer/RegisterProductPage';
import ProblemDetailPage from './pages/customer/ProblemDetailPage';
import ProductWarrantyDetailPage from './pages/customer/ProductWarrantyDetailPage';
import NotificationDetailPage from './pages/customer/NotificationDetailPage';

// PROTECTED TECHNICIAN PAGES
import TechnicianDashboardPage from './pages/technician/TechnicianDashboardPage';
import TechnicianFAQPage from './pages/technician/TechnicianFAQPage';
import TechnicianProfilePage from './pages/technician/TechnicianProfilePage';
import TechnicianSupportPage from './pages/technician/TechnicianSupportPage';
import VideoLibraryPage from './pages/technician/VideoLibraryPage';
import VideoViewPage from './pages/technician/VideoViewPage';
import TechnicianWorkOrdersPage from './pages/technician/TechnicianWorkOrdersPage';
import TechnicianClientEquipmentPage from './pages/technician/TechnicianClientEquipmentPage';
import TechnicianAlertsPage from './pages/technician/TechnicianAlertsPage';
// No need to import ChatInterface here if it's already imported above for public route,
// but if it was only for technicians, you'd import it here.

// PROTECTED ADMIN SECTION
import AdminSection from './pages/admin';

// Global Styles
import './App.css';

const RECOVERY_IN_PROGRESS_KEY = 'supabase_recovery_in_progress';
const RECOVERY_EMAIL_KEY = 'supabase_recovery_email';

// --- ProtectedRoute Component ---
const ProtectedRoute = ({ children, allowedRoles }) => {
  const location = useLocation();
  const navigate = useNavigate();
  const { t } = useTranslation();
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [userRole, setUserRole] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [authError, setAuthError] = useState(null);

  useEffect(() => {
    let isMounted = true;

    const cleanupRecoveryFlags = () => {
        localStorage.removeItem(RECOVERY_IN_PROGRESS_KEY);
        localStorage.removeItem(RECOVERY_EMAIL_KEY);
    };

    const checkAuthAndRole = async () => {
      if (!isMounted) return;
      setIsLoading(true);
      setAuthError(null);

      const { data: { session }, error: sessionError } = await supabase.auth.getSession();
      if (!isMounted) return;

      if (sessionError) {
        console.error("ProtectedRoute: Session error:", sessionError);
        setIsAuthenticated(false); setUserRole(null);
        setAuthError(t("protectedRoute.sessionError"));
        cleanupRecoveryFlags();
        setIsLoading(false); return;
      }

      if (session) {
        if (localStorage.getItem(RECOVERY_IN_PROGRESS_KEY) === 'true') {
          // If recovery is in progress, user should only be on /set-password.
          // If they navigate elsewhere with this flag, it's an invalid state. Sign them out.
          if (location.pathname !== '/set-password') {
            console.warn("ProtectedRoute: User with active recovery flag tried to access:", location.pathname, "Signing out and clearing recovery flags.");
            await supabase.auth.signOut();
            cleanupRecoveryFlags();
            setIsAuthenticated(false); setUserRole(null);
            setAuthError(t("protectedRoute.mustCompletePasswordReset"));
            // No navigate here, will fall through to !isAuthenticated logic
            setIsLoading(false);
            return; 
          }
          // If on /set-password with recovery flag, let SetPasswordPage handle it.
          // ProtectedRoute shouldn't block /set-password if it's wrapped, but /set-password usually isn't.
          // This check is more for if a user tries to navigate *away* from /set-password while the flag is set.
        }

        setIsAuthenticated(true);
        const userId = session.user.id;
        try {
          const { data: userData, error: userError } = await supabase.from('Users').select('role').eq('id', userId).single();
          if (!isMounted) return;
          if (userError || !userData) {
            console.error("ProtectedRoute: Error fetching user role or no user data:", userError);
            setUserRole(null); setAuthError(t("protectedRoute.profileError"));
            await supabase.auth.signOut(); setIsAuthenticated(false);
            cleanupRecoveryFlags(); // Clean up in case this was related to a botched recovery attempt
          } else {
            setUserRole(userData.role);
          }
        } catch (err) {
          if (!isMounted) return;
          console.error("ProtectedRoute: Unexpected error fetching role:", err);
          setUserRole(null); setAuthError(t("protectedRoute.unexpectedRoleError"));
          await supabase.auth.signOut(); setIsAuthenticated(false);
          cleanupRecoveryFlags();
        }
      } else {
        setIsAuthenticated(false); setUserRole(null);
        // If no session, ensure recovery flags are cleared as they are only valid with a recovery session.
        cleanupRecoveryFlags();
      }

      if (isMounted) setIsLoading(false);
    };

    checkAuthAndRole();

    const { data: { subscription } } = supabase.auth.onAuthStateChange((_event, currentSession) => {
      if (isMounted) {
        console.log("ProtectedRoute: Auth state changed:", _event, "Session:", !!currentSession);
        // Re-check auth and role, which will also handle recovery flag logic.
        checkAuthAndRole();
      }
    });

    return () => {
      isMounted = false;
      if (subscription) {
        subscription.unsubscribe();
      }
    };
  }, [t, location.pathname, navigate]);


  if (isLoading) {
    return (
      <div style={{ textAlign: 'center', padding: '50px', color: 'var(--text-color)', height: '100vh', display: 'flex', flexDirection: 'column', justifyContent: 'center', alignItems: 'center', background: 'var(--primary-bg)' }}>
        <h2>{t("protectedRoute.verifyingAccess")}</h2><p>{t("protectedRoute.pleaseWait")}</p><div className="loading-spinner" style={{ marginTop: '20px' }}></div>
      </div>);
  }

  if (!isAuthenticated) {
    const messageForRedirect = authError || t("protectedRoute.authRequired");
    // Pass along any authError to the login page if needed
    return <Navigate to="/login" state={{ from: location, authError: messageForRedirect }} replace />;
  }

  if (allowedRoles && userRole && !allowedRoles.includes(userRole)) {
    let fallbackPath = '/'; // Default fallback
    // Determine a more specific fallback based on the actual user role
    if (userRole === 'customer') fallbackPath = '/customer/dashboard';
    else if (userRole === 'technician') fallbackPath = '/technician/dashboard';
    else if (userRole === 'admin') fallbackPath = '/admin/dashboard';
    
    // Prevent redirect loop if already on their role's dashboard but somehow mismatched
    if (location.pathname === fallbackPath && fallbackPath !== '/') {
        // If they are on their correct dashboard but somehow this check triggers, send to absolute home
        fallbackPath = '/'; 
    }
    console.log(`ProtectedRoute: Role mismatch. User role: ${userRole}, Allowed: ${allowedRoles.join(', ')}. Redirecting to ${fallbackPath}`);
    return <Navigate to={fallbackPath} replace state={{ unauthorizedFrom: location.pathname, message: t("protectedRoute.roleMismatch") }} />;
  }

  return children;
};


// --- RedirectIfAuthenticated Component ---
const RedirectIfAuthenticated = ({ children }) => {
  const { t } = useTranslation();
  const [isLoading, setIsLoading] = useState(true);
  const [redirectPath, setRedirectPath] = useState(null);
  const location = useLocation();
  const navigate = useNavigate();
  const [urlSearchParams] = useSearchParams();

  useEffect(() => {
    let isMounted = true;

    const checkAuthAndRedirect = async () => {
      if (!isMounted) return;
      setIsLoading(true);
      setRedirectPath(null); // Reset redirect path on each check

      const isOnSetPasswordPage = location.pathname === '/set-password';
      const hasRecoveryTokenInUrl = urlSearchParams.get('token') && urlSearchParams.get('type') === 'recovery';
      const hasRecoveryFlagInStorage = localStorage.getItem(RECOVERY_IN_PROGRESS_KEY) === 'true';

      // If on /set-password page AND (there's a recovery token in URL OR recovery flag in localStorage),
      // then let SetPasswordPage handle its logic. Do not redirect from here.
      if (isOnSetPasswordPage && (hasRecoveryTokenInUrl || hasRecoveryFlagInStorage)) {
        console.log("RedirectIfAuthenticated: Allowing /set-password page to render due to recovery indicators.");
        if (isMounted) {
          setIsLoading(false);
          // setRedirectPath(null) is already done above.
        }
        return; // Important: stop further execution in this function for this case
      }

      // For all other pages, or /set-password without recovery indicators, check session for potential redirect.
      const { data: { session }, error: sessionError } = await supabase.auth.getSession();
      if (!isMounted) return;

      if (sessionError) {
        console.error("RedirectIfAuthenticated: Session error:", sessionError);
        // Treat session error as "not authenticated" for redirection purposes from auth pages.
        // Clear recovery flags just in case, as session state is uncertain.
        localStorage.removeItem(RECOVERY_IN_PROGRESS_KEY);
        localStorage.removeItem(RECOVERY_EMAIL_KEY);
        if (isMounted) setIsLoading(false);
        return;
      }

      if (session) {
        // Session exists. User is authenticated.
        // If they are on an auth page (login, signup, forgot-password), redirect them.
        // /set-password without recovery indicators is also an auth page they shouldn't be on if logged in.
        const authPages = ['/login', '/signup', '/forgot-password', '/set-password'];
        if (authPages.includes(location.pathname)) {
            const userId = session.user.id;
            try {
                const { data: userData, error: userError } = await supabase.from('Users').select('role').eq('id', userId).single();
                if (!isMounted) return;

                if (userError || !userData?.role) {
                    console.error("RedirectIfAuthenticated: Error fetching role or no role data for existing session. Signing out.", userError);
                    await supabase.auth.signOut();
                    localStorage.removeItem(RECOVERY_IN_PROGRESS_KEY); // Clean up fully
                    localStorage.removeItem(RECOVERY_EMAIL_KEY);
                    // Stay on current page (auth page) as user is now signed out.
                    if (isMounted) setIsLoading(false);
                } else {
                    const userRole = userData.role;
                    let pathToRedirect = '/'; // Default
                    if (userRole === 'customer') pathToRedirect = '/customer/dashboard';
                    else if (userRole === 'technician') pathToRedirect = '/technician/dashboard';
                    else if (userRole === 'admin') pathToRedirect = '/admin/dashboard';
                    
                    console.log(`RedirectIfAuthenticated: User (role ${userRole}) on auth page ${location.pathname}. Redirecting to ${pathToRedirect}.`);
                    if (isMounted) setRedirectPath(pathToRedirect);
                }
            } catch (err) {
                if (!isMounted) return;
                console.error("RedirectIfAuthenticated: Unexpected error fetching role. Signing out.", err);
                await supabase.auth.signOut();
                localStorage.removeItem(RECOVERY_IN_PROGRESS_KEY);
                localStorage.removeItem(RECOVERY_EMAIL_KEY);
                if (isMounted) setIsLoading(false);
            }
        }
        // If user is authenticated and NOT on an auth page, do nothing, let them stay.
      } else {
        // No session, user is not authenticated.
        // Clear recovery flags if they exist, as they are only valid with a (recovery) session.
        localStorage.removeItem(RECOVERY_IN_PROGRESS_KEY);
        localStorage.removeItem(RECOVERY_EMAIL_KEY);
        // Let them stay on the current page (presumably an auth page or public page).
      }
      
      if (isMounted) setIsLoading(false);
    };

    checkAuthAndRedirect();

    const { data: { subscription } } = supabase.auth.onAuthStateChange((_event, currentSession) => {
        if (isMounted) {
            console.log("RedirectIfAuthenticated: Auth state changed event:", _event, "Session:", !!currentSession);
            checkAuthAndRedirect(); // Re-evaluate based on new auth state
        }
    });

    return () => {
        isMounted = false;
        if (subscription) {
            subscription.unsubscribe();
        }
    };
  }, [location.pathname, urlSearchParams, navigate, t]); // Add navigate and t to dependencies

  if (isLoading) {
    return (
      <div style={{ textAlign: 'center', padding: '50px', color: 'var(--text-color)', height: '100vh', display: 'flex', flexDirection: 'column', justifyContent: 'center', alignItems: 'center', background: 'var(--primary-bg)' }}>
        <h2>{t("redirectIfAuthenticated.verifyingConnection")}</h2><p>{t("redirectIfAuthenticated.pleaseWait")}</p><div className="loading-spinner" style={{ marginTop: '20px' }}></div>
      </div>);
  }

  if (redirectPath) {
    console.log("RedirectIfAuthenticated: Executing redirect to", redirectPath);
    return <Navigate to={redirectPath} replace />;
  }

  return children;
};

// Helper Wrappers
const CustomerMyProblemsWrapper = () => (<Routes><Route index element={<CustomerMyProblems />} /><Route path="detail/:problemId" element={<ProblemDetailPage />} /><Route path="*" element={<Navigate to="." replace />} /></Routes>);
const CustomerKnowledgeBaseWrapper = () => (<Routes><Route index element={<CustomerKnowledgeBase />} /><Route path="*" element={<Navigate to="." replace />} /></Routes>);
const CustomerWarrantyProductsWrapper = () => (<Routes><Route index element={<CustomerWarrantyProducts />} /><Route path=":productId" element={<ProductWarrantyDetailPage />} /><Route path="*" element={<Navigate to="." replace />} /></Routes>);
const CustomerMyProductsWrapper = () => (<Routes><Route index element={<MyProductsPage />} /><Route path="*" element={<Navigate to="." replace />} /></Routes>);
const CustomerNotificationsWrapper = () => (<Routes><Route index element={<CustomerNotifications />} /><Route path="detail/:notificationId" element={<NotificationDetailPage />} /><Route path="*" element={<Navigate to="." replace />} /></Routes>);
const TechnicianVideoWrapper = () => (<Routes><Route index element={<VideoLibraryPage />} /><Route path=":videoId" element={<VideoViewPage />} /><Route path="*" element={<Navigate to="/technician/videos" replace />} /></Routes>);

// Fallback for Suspense when loading translations
const AppLoadingFallback = () => {
    const { t } = useTranslation();
    return (
      <div style={{ textAlign: 'center', padding: '50px', color: 'var(--text-color)', height: '100vh', display: 'flex', flexDirection: 'column', justifyContent: 'center', alignItems: 'center', background: 'var(--primary-bg)' }}>
        <h2>{t('loading', 'Loading...')}</h2>
      </div>
    );
};


function App() {
  const { t, i18n } = useTranslation();
  const isDevelopment = process.env.NODE_ENV !== 'production';

  const handleDevLogout = async () => {
      await supabase.auth.signOut();
      localStorage.removeItem(RECOVERY_IN_PROGRESS_KEY);
      localStorage.removeItem(RECOVERY_EMAIL_KEY);
      window.location.href = '/login'; // Hard redirect to clear state
  };

  useEffect(() => {
    document.documentElement.lang = i18n.language;
    document.documentElement.dir = i18n.dir(i18n.language);
  }, [i18n, i18n.language]);


  return (
      <Suspense fallback={<AppLoadingFallback />}>
      {isDevelopment && ( <div style={{ position: 'fixed', bottom: '10px', right: '10px', zIndex: 9999, background: 'rgba(0,0,0,0.8)', padding: '10px', borderRadius: '5px' }}><button onClick={handleDevLogout} style={{ padding: '4px 8px', fontSize: '11px', cursor: 'pointer', background: 'var(--status-error-text, red)', color: 'var(--text-color, white)', border: 'none', borderRadius: '4px' }}>{t('devLogout', 'Dev Logout')}</button></div>)}
      <Routes>
        {/* --- PUBLIC ROUTES --- */}
        <Route path="/" element={<HomePage />} />
        <Route path="/public-about" element={<PublicAboutPage />} />
        <Route path="/ai-chatbot-demo" element={<ChatInterface />} />
        <Route path="/report-website-issue" element={<PublicReportIssuePage />} />
        <Route path="/contact-support" element={<ContactSupportPage />} />
        <Route path="/privacy-policy" element={<PrivacyPolicyPage />} />
        <Route path="/terms-of-use" element={<TermsOfUsePage />} />

        {/* --- AUTH ROUTES --- */}
        {/* AuthSwitcherPage handles both /login and /signup internally */}
        <Route path="/login" element={<RedirectIfAuthenticated><AuthSwitcherPage /></RedirectIfAuthenticated>} />
        <Route path="/signup" element={<RedirectIfAuthenticated><AuthSwitcherPage /></RedirectIfAuthenticated>} />
        <Route path="/forgot-password" element={<RedirectIfAuthenticated><ForgotPasswordPage /></RedirectIfAuthenticated>} />
        {/* SetPasswordPage is wrapped with RedirectIfAuthenticated, which now has special handling for it */}
        <Route path="/set-password" element={<RedirectIfAuthenticated><SetPasswordPage /></RedirectIfAuthenticated>} />


        {/* --- CUSTOMER PROTECTED ROUTES --- */}
        <Route path="/customer" element={<ProtectedRoute allowedRoles={['customer']}><CustomerLayout /></ProtectedRoute>} >
          <Route index element={<Navigate to="dashboard" replace />} />
          <Route path="dashboard" element={<CustomerDashboard />} />
          <Route path="profile" element={<CustomerProfile />} />
          <Route path="report-issue" element={<CustomerReportIssue />} />
          <Route path="my-products/*" element={<CustomerMyProductsWrapper />} />
          <Route path="warranty-products/*" element={<CustomerWarrantyProductsWrapper />} />
          <Route path="register-product" element={<RegisterProductPage />} />
          <Route path="knowledge-base/*" element={<CustomerKnowledgeBaseWrapper />} />
          <Route path="my-problems/*" element={<CustomerMyProblemsWrapper />} />
          <Route path="notifications/*" element={<CustomerNotificationsWrapper />} />
          <Route path="settings" element={<SettingsPage />} />
          <Route path="about" element={<AboutPage />} />
          <Route path="faq" element={<FAQPage />} />
          <Route path="*" element={<Navigate to="dashboard" replace />} /> {/* Fallback for unknown /customer routes */}
        </Route>

        {/* --- TECHNICIAN PROTECTED ROUTES --- */}
        <Route path="/technician" element={<ProtectedRoute allowedRoles={['technician']}><TechnicianLayout /></ProtectedRoute>} >
          <Route index element={<Navigate to="dashboard" replace />} />
          <Route path="dashboard" element={<TechnicianDashboardPage />} />
          <Route path="faq" element={<TechnicianFAQPage />} />
          <Route path="profile" element={<TechnicianProfilePage />} />
          <Route path="support" element={<TechnicianSupportPage />} />
          <Route path="videos/*" element={<TechnicianVideoWrapper />} />
          <Route path="work-orders" element={<TechnicianWorkOrdersPage />} />
          <Route path="equipment" element={<TechnicianClientEquipmentPage />} />
          <Route path="alerts" element={<TechnicianAlertsPage />} />
          {/* 👇 THIS IS THE ADDED ROUTE FOR THE TECHNICIAN CHATBOT 👇 */}
          <Route path="chatbot" element={<ChatInterface />} />
          <Route path="*" element={<Navigate to="dashboard" replace />} /> {/* Fallback for unknown /technician routes */}
        </Route>

        {/* --- ADMIN PROTECTED ROUTES --- */}
        <Route path="/admin/*" element={<ProtectedRoute allowedRoles={['admin']}><AdminSection /></ProtectedRoute>} />

        {/* --- 404 NOT FOUND --- */}
        {/* This should be the last route */}
        <Route path="*" element={ <div style={{ textAlign: 'center', padding: '50px', color: 'var(--text-color, white)', backgroundColor: 'var(--primary-bg, #0E1330)', height: '100vh', display: 'flex', flexDirection: 'column', justifyContent: 'center', alignItems: 'center' }}> <h2 style={{ fontSize: '2.5rem', marginBottom: '1rem' }}>{t("pageNotFound.title", "Page Not Found")}</h2> <p style={{ fontSize: '1.1rem', marginBottom: '2rem' }}>{t("pageNotFound.message", "The page you are looking for does not exist.")}</p> <Link to="/" style={{ color: 'var(--accent-color, #1690BF)', fontSize: '1.1rem', textDecoration: 'underline', padding: '10px 20px', border: '1px solid var(--accent-color, #1690BF)', borderRadius: 'var(--border-radius-card, 8px)' }}> {t("pageNotFound.goHome", "Go Home")} </Link> </div> } />
      </Routes>
      </Suspense>
  );
}

export default App;